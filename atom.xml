<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[邢秀东的网络日志]]></title>
  <subtitle><![CDATA[使你疲劳的不是远方的高山，而且是你鞋里面的一粒砂子]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xingxiudong.com/"/>
  <updated>2015-01-28T05:44:04.802Z</updated>
  <id>http://xingxiudong.com/</id>
  
  <author>
    <name><![CDATA[Xiudong Xing]]></name>
    <email><![CDATA[xingxiudong@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[防止ElasticSearch集群出现脑裂现象的解决办法]]></title>
    <link href="http://xingxiudong.com/2015/01/05/resolve-elasticsearch-split-brain/"/>
    <id>http://xingxiudong.com/2015/01/05/resolve-elasticsearch-split-brain/</id>
    <published>2015-01-05T06:45:19.000Z</published>
    <updated>2015-01-05T07:29:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="什么是“脑裂”现象？">什么是“脑裂”现象？</h1>
<p>由于某些节点的失效，部分节点的网络连接会断开，并形成一个与原集群一样名字的集群，这种情况称为集群脑裂（split-brain）现象。这个问题非常危险，因为两个新形成的集群会同时索引和修改集群的数据。<br><a id="more"></a></p>
<p><!--http://www.elasticsearch.org/content/themes/elasticsearch-org/images/logo.png --><br><img src="http://i3.tietuku.com/575cab6c397310e6.png" alt=""></p>
<h1 id="如何避免脑裂问题？">如何避免脑裂问题？</h1>
<p>避免脑裂现象，用到的一个参数是：discovery.zen.minimum_master_nodes。这个参数决定了要选举一个Master需要多少个节点（最少候选节点数）。默认值是1。根据一般经验这个一般设置成 N/2 + 1，N是集群中节点的数量，例如一个有3个节点的集群，minimum_master_nodes 应该被设置成 3/2 + 1 = 2（向下取整）。</p>
<p>用到的另外一个参数是：discovery.zen.ping.timeout，等待ping响应的超时时间，默认值是3秒。如果网络缓慢或拥塞，建议略微调大这个值。这个参数不仅仅适应更高的网络延迟，也适用于在一个由于超负荷而响应缓慢的节点的情况。</p>
<p>如果您刚开始使用<a href="http://www.elasticsearch.org/" target="_blank" rel="external">elasticsearch</a>，建议搭建拥有3个节点的集群，这种方式可以把discovery.zen.minimum_master_nodes设置成2，这样就限制了发生脑裂现象的可能，且保持着高度的可用性：如果你设置了副本，在丢失一个节点的情况下，集群仍可运行。</p>
<h1 id="真的高枕无忧了？">真的高枕无忧了？</h1>
<p>其实问题依然存在，ES的issue空间也在讨论一个特例情况<a href="https://github.com/elasticsearch/elasticsearch/issues/2488" target="_blank" rel="external">《#2488》</a>：即使 minimum_master_nodes 设置了一个正确的值，脑裂也有可能发生。</p>
<h1 id="如何识别这个问题？">如何识别这个问题？</h1>
<p>在您的集群里面尽快识别这个问题非常重要。一个比较容易的方法是定时获取每一个节点/_nodes响应，它返回了集群中所有节点的状态报告，如果两个节点返回的集群状态不一样，就是一个脑裂情况发生的警示信号。</p>
<h1 id="新增解决方案">新增解决方案</h1>
<p>对于一个具有全功能的ES节点，必须要有一个活动的Master节点。ES1.4.0.Beta1后，新增了一项没有Master时阻塞集群操作设置：<a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.4/modules-discovery-zen.html#no-master-block" target="_blank" rel="external">discovery.zen.no_master_block</a>。</p>
<p>当集群中没有活动的Master节点后，该设置指定了哪些操作（read、write）需要被拒绝（即阻塞执行）。有两个设置值：all和write，默认为wirte。</p>
<p>这项配置不会对基本api（例如集群状态、节点信息和状态API）产生影响，这些节点在任何节点上执行都不会被阻塞。</p>
<h1 id="总结">总结</h1>
<p>脑裂问题依然是一个比较难以解决的问题，最终解决方案也是妥协的结果。这个问题也是分布式系统都会面临的问题。一下子想到了前几天看到的CAP理论，难道只有CP或者AP？<br>总体感觉ES还很年轻，但因为它的开箱即用、天生集群、自动容错、扩展性强等优点，还是选择它来做全文检索。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="http://blog.trifork.com/2013/10/24/how-to-avoid-the-split-brain-problem-in-elasticsearch/" target="_blank" rel="external">HOW TO AVOID THE SPLIT-BRAIN PROBLEM IN ELASTICSEARCH</a></li>
<li><a href="https://github.com/elasticsearch/elasticsearch/issues/2488" target="_blank" rel="external">minimum_master_nodes does not prevent split-brain if splits are intersecting #2488</a></li>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.4/modules-discovery-zen.html#no-master-block" target="_blank" rel="external">zen discovery</a></li>
<li><a href="https://www.gitbook.com/book/shgy/mastering-elasticsearch" target="_blank" rel="external">《Mastering Elasticsearch(中文版)》</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="什么是“脑裂”现象？">什么是“脑裂”现象？</h1>
<p>由于某些节点的失效，部分节点的网络连接会断开，并形成一个与原集群一样名字的集群，这种情况称为集群脑裂（split-brain）现象。这个问题非常危险，因为两个新形成的集群会同时索引和修改集群的数据。<br>]]>
    
    </summary>
    
      <category term="elasticsearch" scheme="http://xingxiudong.com/tags/elasticsearch/"/>
    
      <category term="elasticsearch" scheme="http://xingxiudong.com/categories/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim常用命令分享PPT]]></title>
    <link href="http://xingxiudong.com/2014/12/23/vim-common-command-ppt-brief/"/>
    <id>http://xingxiudong.com/2014/12/23/vim-common-command-ppt-brief/</id>
    <published>2014-12-23T04:59:34.000Z</published>
    <updated>2015-01-07T02:42:13.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/ppt/vim-common-command-ppt.html">在线浏览PPT</a><br><a id="more"></a></p>
<h1 id="内容提纲">内容提纲</h1>
<ul>
<li>引言<ul>
<li>读者群体</li>
<li>为什么要使用vim？</li>
<li>提前准备</li>
</ul>
</li>
<li>入门<ul>
<li>工作模式</li>
<li>基本命令</li>
</ul>
</li>
<li>进阶<ul>
<li>快速移动光标</li>
<li>快速编辑</li>
<li>复制和粘贴</li>
<li>查找和替换</li>
</ul>
</li>
<li>高级用法<ul>
<li>翻页</li>
<li>移动屏幕</li>
<li>书签</li>
<li>宏</li>
<li>visual模式</li>
<li>列编辑</li>
<li>分屏</li>
<li>其他</li>
</ul>
</li>
<li>附：命令模式下常用命令</li>
</ul>
<h1 id="引言">引言</h1>
<h2 id="读者群体">读者群体</h2>
<ul>
<li>经常与linux打交道的人</li>
<li>程序猿、攻城狮、技术狂</li>
<li>对vim感兴趣的人</li>
</ul>
<h2 id="为什么要使用vim？">为什么要使用vim？</h2>
<ul>
<li>操作简洁、高效</li>
<li>跨平台</li>
<li>编程式编辑</li>
<li>优秀的工具和文档 vimtutor</li>
</ul>
<h2 id="提前准备">提前准备</h2>
<ul>
<li>学习曲线陡峭</li>
<li>身心是痛苦的</li>
<li>需要时间</li>
<li>不断练习和磨练</li>
</ul>
<h1 id="一、入门">一、入门</h1>
<h2 id="工作模式">工作模式</h2>
<ol>
<li>Normal模式     Esc</li>
<li>插入模式         i</li>
<li>命令模式         :</li>
<li>可视化模式     v，V，Ctrl-v</li>
</ol>
<h2 id="基本命令">基本命令</h2>
<ul>
<li>移动光标<pre><code>       ^
       k              <span class="variable">Hint</span>:  h 键在左边，左移.
 &lt; h       l &gt;               l 键在右边，右移.
       j                     j 键看上去像一个向下的箭头，下移.
       v
</code></pre></li>
<li>编辑<pre><code>  <span class="built_in">i</span>
</code></pre></li>
<li>撤销和重做<pre><code>  u, Ctrl-R
</code></pre></li>
<li>保存和退出<pre><code>  <span class="symbol">:w</span>, <span class="symbol">:q</span>, <span class="symbol">:x</span>
</code></pre></li>
</ul>
<h1 id="二、进阶">二、进阶</h1>
<h2 id="快速移动光标">快速移动光标</h2>
<p>以下操作在Normal模式下执行，按Esc进入。</p>
<ul>
<li>行内移动光标<pre><code>  ^, $, <span class="number">0</span>
  w, W
  b, B
  e, <span class="keyword">E</span>
  f, F
  <span class="number">2</span>f<span class="list">{X}</span>, <span class="list">{n}</span>F<span class="list">{X}</span>
</code></pre></li>
<li>行间移动光标<pre><code><span class="attribute">  {n}G, G
  gg                    → </span>=<span class="string">1G</span>
</code></pre></li>
<li>按匹配括号移动光标（“(” “)”，“[” “]”，“{” “}”等等）<pre><code>  <span class="comment">%</span>
</code></pre></li>
<li>屏内移动光标<pre><code>  H, M, L
</code></pre></li>
<li>按句移动光标<pre><code>  <span class="list">(, )</span>
</code></pre></li>
<li>按代码块“{” “}”移动光标（要求“{”或“}”独占一行）<pre><code>  <span class="string">[[, ]]</span>
</code></pre></li>
<li>移动光标至上次停留的位置<pre><code>  <span class="string">''</span>                     → 两个单引号
</code></pre></li>
<li>移动光标至上次上一次的修改行<pre><code>  &#39;.
</code></pre></li>
<li><p>移动光标至上次上一次的修改点</p>
<pre><code>  `.
</code></pre><h2 id="快速编辑">快速编辑</h2>
</li>
<li><p>进入编辑模式</p>
<pre><code>  <span class="keyword">I</span>, i
  a, A
  x, X
  d, <span class="keyword">D</span>(=d$)
  c, <span class="keyword">C</span>(=c$)
  r, R
</code></pre></li>
<li>快速删除<pre><code>  dd, dw, de, d{n}w, df{char}, dt{char}, {n}dd, dgg, d{n}gg, dG, <span class="keyword">...</span>
  cc, cw, ce, c{n}w, cf{char}, ct{char}, {n}cc, cgg, c{n}gg, cG, <span class="keyword">...</span>
</code></pre></li>
<li>重复操作<pre><code>  .
  <span class="tuple">{n}</span>.
</code></pre></li>
<li>大写和小写<pre><code>  gU                     → 变大写命令
  <span class="keyword">gu</span>                     → 变小写命令
</code></pre></li>
<li>更快<pre><code>  &lt;start position&gt;&lt;<span class="command"><span class="keyword">command</span>&gt;&lt;<span class="title">end</span> <span class="title">position</span>&gt;</span>
                         → <span class="command"><span class="keyword">command</span>可以是<span class="title">d</span>, <span class="title">y</span>, <span class="variable">gU</span>, <span class="title">gu</span>...</span>
  <span class="number">0</span>y$
</code></pre></li>
</ul>
<h2 id="复制和粘贴">复制和粘贴</h2>
<ul>
<li>复制<pre><code>  yy, yw, ye, y{n}w, yf{char}, yt{char}, {n}yy, ygg, y{n}gg, yG, <span class="keyword">...</span>
  Y(=yy)
</code></pre></li>
<li>粘贴<pre><code>  p, P
</code></pre></li>
</ul>
<h2 id="查找和替换">查找和替换</h2>
<ul>
<li>向后查找<pre><code>  /
</code></pre></li>
<li>向前查找<pre><code>  ?
</code></pre></li>
<li>查找下一个<pre><code>  n, <span class="keyword">N</span>
</code></pre></li>
<li><p>替换</p>
<pre><code>  :s/<span class="list">{old}</span>/<span class="list">{new}</span>         → 替换当前行第一个<span class="list">{old}</span>为<span class="list">{new}</span>
  :s/<span class="list">{old}</span>/<span class="list">{new}</span>/g       → 替换当前行所有的<span class="list">{old}</span>为<span class="list">{new}</span>
  :s/<span class="list">{old}</span>/<span class="list">{new}</span>/c       → 替换当前行所有的<span class="list">{old}</span>为<span class="list">{new}</span>, 每次提醒

  :%s/<span class="list">{old}</span>/<span class="list">{new}</span>        → 替换所有行的<span class="list">{old}</span>为<span class="list">{new}</span>
  :<span class="list">{start-row-num}</span>,<span class="list">{end-row-num}</span>s/<span class="list">{old}</span>/<span class="list">{new}</span>
                         → 替换<span class="list">{start-row-num}</span>行至<span class="list">{end-row-num}</span>行的<span class="list">{old}</span>为<span class="list">{new}</span>
  :<span class="list">{n}</span>,$s/<span class="list">{old}</span>/<span class="list">{new}</span>    → 替换替换第<span class="list">{n}</span>行开始到最后一行中每一行所有的<span class="list">{old}</span>为<span class="list">{new}</span>

  :s#<span class="list">{old}</span>#<span class="list">{new}</span>         → / 不会作为分隔符
</code></pre></li>
</ul>
<h1 id="三、高级用法">三、高级用法</h1>
<h2 id="翻页">翻页</h2>
<ul>
<li>向上翻页<pre><code>  <span class="title">Ctrl</span> + f               → (page forword)向下整页翻页
</code></pre></li>
<li>向下翻页<pre><code>  <span class="title">Ctrl</span> + b               → (page backward)向上整页翻页
</code></pre></li>
<li>向上翻半页<pre><code>  Ctrl + <span class="keyword">u</span>               → (page <span class="keyword">up</span>)向上翻半页
</code></pre></li>
<li>向下翻半页<pre><code>  Ctrl + d               → (page <span class="preprocessor">down</span>)向下翻半页
</code></pre></li>
</ul>
<h2 id="移动屏幕">移动屏幕</h2>
<ul>
<li>移动屏幕，使光标所在行位于屏幕中间<pre><code>  zz
</code></pre></li>
<li>移动屏幕，使光标所在行位于屏幕顶部<pre><code>  zt
</code></pre></li>
<li>移动屏幕，使光标所在行位于屏幕底部<pre><code>  zb
</code></pre></li>
</ul>
<h2 id="书签">书签</h2>
<ul>
<li>设定书签<pre><code>  m<span class="list">{a-z}</span>                → 小写字母应用域为单个文件，大写字母可应用域为全局
</code></pre></li>
<li>跳转到书签<pre><code>  <span class="escape">`{</span><span class="literal">a</span>-z} 或 '{<span class="literal">a</span>-z}
</code></pre></li>
<li>查看书签<pre><code>  <span class="symbol">:marks</span>
</code></pre></li>
</ul>
<h2 id="宏">宏</h2>
<ul>
<li>录制宏<pre><code>  开始录制：<span class="string">q{a-z}</span>
  完成录制：<span class="keyword">q</span>
</code></pre></li>
<li>播放宏<pre><code>  <span class="decorator">@{a-z}</span>
  <span class="decorator">@@</span>
</code></pre></li>
</ul>
<blockquote>
<p>示例：qaYp<c-a>q<br>@a<br>@@<br>100@@</c-a></p>
</blockquote>
<h2 id="visual模式">visual模式</h2>
<pre><code>v, V
Ctrl + v
</code></pre><h2 id="列编辑">列编辑</h2>
<pre><code>（Ctrl + v）  +  <span class="keyword">I</span> 
</code></pre><h2 id="分屏">分屏</h2>
<pre><code><span class="symbol">:split</span>
vsplit
<span class="constant">Ctrl</span> + w, <span class="constant">Ctrl</span> + w + (←↓↑→)  切换分屏
</code></pre><h2 id="其他">其他</h2>
<ul>
<li>寄存器<pre><code>  <span class="string">"{a-Z}, {A-Z}</span>
</code></pre></li>
<li>获取系统剪贴板<pre><code>  <span class="string">"+ 或 "</span><span class="keyword">*</span>
</code></pre></li>
</ul>
<h1 id="附：命令模式下常用命令">附：命令模式下常用命令</h1>
<ul>
<li>跳转到指定行<pre><code>  :{<span class="keyword">int</span>-number}          → 跳转到行号为{<span class="keyword">int</span>-number}的行
</code></pre></li>
<li>设置显示行号<pre><code>  :<span class="operator"><span class="keyword">set</span> <span class="built_in">number</span>            → 显示行号
  :<span class="keyword">set</span> nonumber          → 隐藏行号
  :<span class="keyword">set</span> <span class="built_in">number</span>!           → 显示/隐藏行号</span>
</code></pre></li>
<li>设置语法高亮<pre><code>  :syntax <span class="literal">on</span>             → 开启语法高亮
  :syntax <span class="literal">off</span>            → 关闭语法高亮
</code></pre></li>
<li>设置显示不可见字符<pre><code>  <span class="symbol">:set</span> list              → 显示不可见字符, 把制表符显示为^<span class="constant">I</span>, 用<span class="variable">$标</span>示行尾
  <span class="symbol">:set</span> nolist            → 隐藏不可见字符
</code></pre></li>
<li>搜索设置<pre><code>  :<span class="keyword">set</span> ignorecase        → 设定查找时忽略大小写
  :<span class="keyword">set</span> noignorecase      → 取消查找时忽略大小写的设定
  :<span class="keyword">set</span> hlsearch          → 设置高亮搜索的匹配结果
  :<span class="keyword">set</span> nohlsearch        → 取消搜索高亮设置
</code></pre></li>
<li>设置文件格式<pre><code>  :<span class="operator"><span class="keyword">set</span> fileformat        → 显示当前文件格式
  :<span class="keyword">set</span> fileformat={<span class="keyword">format</span>}
                         → 设置当前文件格式</span>
</code></pre></li>
<li>设置文件编码<pre><code>  :<span class="keyword">set</span> encoding          → 显示当前文件编码
  :<span class="keyword">set</span> encoding={encoding}
                         → 设置当前文件格式
</code></pre></li>
</ul>
<blockquote>
<p>这些set命令一般都有简写形式，如 set number! 可简写为 set nu!</p>
</blockquote>
<h1 id="结束语">结束语</h1>
<ul>
<li>本文使用的vim版本是：version 7.2.411</li>
<li>上面讲到的只是常用的命令，还有更多更高级的功能没有提到。</li>
<li>建议经常学习新的命令，多操作。</li>
<li>vim有不少优秀的文档，运行vimtutor直到你熟悉了那些基本命令。</li>
<li>对于经常和Linux打交道的人学习使用vim能提高工作效率。</li>
<li>再也不怕裸系统了。</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<blockquote>
<p><a href="http://www.cnblogs.com/wrmfw/archive/2011/09/08/2170465.html" target="_blank" rel="external">《简明 Vim 练级攻略》</a><br><a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html" target="_blank" rel="external">Graphical vi-vim Cheat Sheet and Tutorial</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="/ppt/vim-common-command-ppt.html">在线浏览PPT</a><br>]]>
    
    </summary>
    
      <category term="linux" scheme="http://xingxiudong.com/tags/linux/"/>
    
      <category term="vim" scheme="http://xingxiudong.com/tags/vim/"/>
    
      <category term="shell" scheme="http://xingxiudong.com/tags/shell/"/>
    
      <category term="linux" scheme="http://xingxiudong.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux初配]]></title>
    <link href="http://xingxiudong.com/2014/11/19/linux-start-config/"/>
    <id>http://xingxiudong.com/2014/11/19/linux-start-config/</id>
    <published>2014-11-19T06:01:21.000Z</published>
    <updated>2015-01-05T07:26:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="引言">引言</h1>
<p>Linux有很多分支，CentOS、Ubuntu…<br>本文以CentOS-6.4-x86_64环境介绍当我们拿到一个Linux系统，我们需要做的一些主要配置。<br><a id="more"></a></p>
<h1 id="安装">安装</h1>
<p>先要<a href="http://www.centos.org/" target="_blank" rel="external">http://www.centos.org/</a>下载系统安装包，一般下载ISO文件，下载后使用虚拟机（有VirtualBox和VMware）安装。<br><a href="http://mirrors.pubyun.com/centos/6.5/isos/x86_64/" target="_blank" rel="external">镜像地址</a>中一般有minimal、bin-DVD、LiveCD、LiveDVD和netinstall五个版本。了解他们的区别可以看下<a href="http://mirrors.pubyun.com/centos/6.5/isos/x86_64/0_README.txt" target="_blank" rel="external">README.txt</a>文件。我只有在安装需要桌面环境的组件（如VNC-Server、Oracle）时使用bin-DVD版，一般都使用minimal版本安装，即最小软件包安装，系统简洁干净，一般400M左右。</p>
<p>写这篇文章安装使用的虚拟机环境是VMware® Workstation 10.0.0，其安装在Window8.1 企业版上。</p>
<h1 id="网络配置">网络配置</h1>
<p>首先要让系统能上网才是王道。<br>VMware中的网络连接模式为NAT模式时，主机和虚拟机之间可互联互通。<br>在NAT模式下，虚拟机可以通过宿主主机连接公网，当然如果宿主机可上网，虚拟机也就可以上网了，但这太虚拟机只能与主机通信。如果需要将虚拟机虚拟成主机所在局域网中的一台独立主机，拥有和主机平起平坐的地址，那需要Bridged模式，即桥接模式。</p>
<p>我使用的是NAT模式，原因很简单：公司不允许在局域网中虚拟独立主机，局域网IP地址资源受限。</p>
<p>NAT模式下虚拟机网卡使用dhcp即可，即自动获取IP。<br>网卡配置文件 <em>/etc/sysconfig/network-scripts/ifcfg-eth0</em> 中默认 <em>ONBOOT</em> 值为 <strong>no</strong>，需要修改为 <strong>yes</strong>，即启动时自动启动网卡（network服务）。</p>
<pre><code>vi <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0
</code></pre><p>打开首次安装的默认配置文件，一般如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DEVICE=eth0</div><div class="line">HWADDR=<span class="number">00</span>:<span class="number">0</span>C:<span class="number">29</span>:<span class="number">7</span>B:C2:E9</div><div class="line">TYPE=Ethernet</div><div class="line">UUID=ce6ea204<span class="operator">-f</span>9dc-<span class="number">4</span>adc-b370-<span class="number">37</span>a9619c042b</div><div class="line">ONBOOT=yes</div><div class="line">NM_CONTROLLED=yes</div><div class="line">BOOTPROTO=dhcp</div></pre></td></tr></table></figure>

<p>如果是桥接模式，对 <em>ifcft-eth0</em> 作如下修改：</p>
<ol>
<li>修改BOOTPROTO=”static”；</li>
<li>修改ONBOOT=”yes”；</li>
<li>新增如下配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">IPADDR=<span class="number">192.168</span>.<span class="number">1.102</span></div><div class="line">NETMASK=<span class="number">255.255</span>.<span class="number">255.0</span></div><div class="line">GATEWAY=<span class="number">192.168</span>.<span class="number">1.1</span></div><div class="line">DNS1=<span class="number">202.102</span>.<span class="number">192.68</span></div><div class="line">DNS2=<span class="number">8.8</span>.<span class="number">8.8</span></div></pre></td></tr></table></figure>

<p>不用解释具体的每项配置。DNS也可以在 <em>/etc/resolv.conf</em> 中配置。</p>
<p>所有修改在启动网卡或重启网络服务后才会生效。</p>
<ul>
<li><p>启动/关闭网卡</p>
<pre><code>  <span class="title">ifup</span> eth0
  ifdown eth0
</code></pre></li>
<li><p>重启网络服务：</p>
<pre><code>  <span class="class"><span class="keyword">service</span> <span class="title">network</span> restart</span>
</code></pre></li>
</ul>
<p>执行 <code>ping www.baidu.com</code> 就可以检查您的配置是否正确了。</p>
<h1 id="更新软件包">更新软件包</h1>
<p>在能上网之后，把系统安装自带的所有软件包更新到最新。</p>
<pre><code>yum <span class="keyword">update</span> -<span class="keyword">y</span>
</code></pre><h1 id="修改主机名">修改主机名</h1>
<p>在安装的过程中很多时候主机名随便设置了一个，安装后想要重新设置主机名。需要修改两个配置。</p>
<ol>
<li><p>修改 <em>/etc/sysconfig/network</em> 文件</p>
<pre><code><span class="constant"> NETWORKING</span>=yes
<span class="constant"> HOSTNAME</span>=&lt;new-host-name&gt;
</code></pre><p> 将HOSTNAME修改为新主机名&lt;new-host-name&gt;。</p>
</li>
<li><p>修改 <em>/etc/hosts</em> 文件<br> 新增行： </p>
<pre><code> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>        &lt;<span class="keyword">new</span>-host-name&gt;;
</code></pre></li>
</ol>
<h1 id="安装常用软件">安装常用软件</h1>
<pre><code>yum install <span class="keyword">make</span> wget <span class="keyword">vim</span> unrar unzip ntpdate traceroute redhat-lsb openssh-clients subversion -<span class="keyword">y</span> 
</code></pre><blockquote>
<p>wget使用时进度条的刷屏问题按如下方式解决：<br>   yum install gettext -y<br>    msgunfmt /usr/share/locale/zh_CN/LC_MESSAGES/wget.mo -o - |sed ‘s/eta(英国中部时间)/ETA/‘|msgfmt - -o/tmp/zh_CN.mo<br>    cp /tmp/zh_CN.mo /usr/share/locale/zh_CN/LC_MESSAGES/wget.mo</p>
</blockquote>
<h1 id="时区和时间">时区和时间</h1>
<p>先检查一下自己所在时区</p>
<pre><code><span class="tag">date</span> <span class="tag">-R</span>
<span class="tag">Wed</span>, 19 <span class="tag">Nov</span> 2014 06<span class="pseudo">:17</span><span class="pseudo">:44</span> +0800
</code></pre><p>如果不是所在时区需要调整，以中国大陆所在时区为例：</p>
<pre><code>cp -f <span class="regexp">/usr/</span>share<span class="regexp">/zoneinfo/</span>Asia<span class="regexp">/Shanghai /</span>etc<span class="regexp">/localtime</span>
</code></pre><p>时间同步很简单，使用 <em>ntpdate &lt;ntpd-server&gt;</em> 命令即可。&lt;ntpd-server&gt; 是时钟服务器地址/域名，网上通过Google查询有很多。我用的是 us.pool.ntp.org。</p>
<pre><code><span class="tag">ntpdate</span> <span class="tag">us</span><span class="class">.pool</span><span class="class">.ntp</span><span class="class">.org</span>
19 <span class="tag">Nov</span> 11<span class="pseudo">:00</span><span class="pseudo">:32</span> <span class="tag">ntpdate</span><span class="attr_selector">[1533]</span>: <span class="tag">step</span> <span class="tag">time</span> <span class="tag">server</span> 137<span class="class">.190</span><span class="class">.2</span><span class="class">.4</span> <span class="tag">offset</span> <span class="tag">-28788</span><span class="class">.508863</span> <span class="tag">sec</span>
</code></pre><p>如果想定时自动作时间同步，将命令加入定时器命令列表即可。执行 <code>crontab -e</code> 新增下面一行，每隔10分钟作一次时间同步：</p>
<pre><code>0-59/10 <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> /usr/sbin/ntpdate us.pool.ntp.org <span class="string">| logger -t NTP</span>
</code></pre><p><strong>:x</strong> 保存后重启crond服务：<code>service crond restart</code></p>
<h1 id="修改开机预设等待时间">修改开机预设等待时间</h1>
<!--![开机时的一个等待画面](/images/linux-start-config-grub.png)-->

<pre><code><span class="keyword">vi</span> /boot/grub/<span class="keyword">menu</span>.lst
</code></pre><p>修改 <em>timeout</em> 值，单位是秒。我喜欢设置为0。</p>
<h1 id="用户和组">用户和组</h1>
<h2 id="添加用户">添加用户</h2>
<p>添加一个 “stonex” 的用户：</p>
<pre><code>useradd –d <span class="regexp">/home/</span>stonex -s <span class="regexp">/bin/</span>bash -g stonex -m stonex
</code></pre><p>-d 表示指定用户主目录，-m 表示如果该主目录不存在创建一个，-s 指定执行的shell， -g 表示指定用户所在组 stonex （不存在会自动生成一个）。<br>CentOS6也可以直接使用 <code>useradd stonex</code>， 默认会在 /home 目录下新建用户主目录 /home/stonex，并且也会自动生成一个用户组 stonex。</p>
<p>在 /etc/group 文件中可看到新增的组 stonex：</p>
<pre><code><span class="tag">stonex</span><span class="pseudo">:x</span><span class="pseudo">:500</span>:
</code></pre><p>并且在 /etc/passwd 文件尾部会新增如下这一行：</p>
<pre><code><span class="symbol">stonex:</span><span class="symbol">x:</span><span class="number">500</span><span class="symbol">:</span><span class="number">500</span><span class="symbol">:</span><span class="symbol">:/home/stonex</span><span class="symbol">:/bin/bash</span>
</code></pre><p>这一行的意思是：用户名:密码:用户ID:组ID:描述:用户主目录:用户shell。<br>密码为x，是为了增强系统的安全性，Linux系统为用户提供MD5和Shadow安全密码服务，可以以 root 身份在 /etc/shadow 中查到具体加密后的密码串值。</p>
<h2 id="修改密码">修改密码</h2>
<pre><code><span class="title">passwd</span> stonex
</code></pre><p>需要输入新密码和确认密码。</p>
<h2 id="添加用户到组">添加用户到组</h2>
<p>新增一个用户组 admin：</p>
<pre><code>groupadd <span class="literal">admin</span>
</code></pre><p>将 stonex 用户添加到组 admin：</p>
<pre><code>usermod <span class="operator">-a</span> -G admin stonex
</code></pre><p>-a 表示将用户追加到指定用户组中，-G 指定用户组名称。</p>
<p>查询 stonex 所在的用户组列表：</p>
<pre><code>groups stonex
stonex : stonex <span class="literal">admin</span>
</code></pre><h2 id="登录">登录</h2>
<pre><code><span class="title">ssh</span> stonex@<span class="number">192.168.1.123</span>
</code></pre><h2 id="一些常用命令">一些常用命令</h2>
<ul>
<li>删除用户:    <code>userdel -r stonex</code> -r 表示删除用户主目录。</li>
<li>查询用户: <code>who</code> 查询当前已登录用户列表，<code>whoami</code> 查询当前登录用户信息。</li>
</ul>
<h1 id="语言设置">语言设置</h1>
<p>修改系统语言环境变量：</p>
<pre><code><span class="keyword">vi</span> /etc/sysconfig/i18n
</code></pre><p>LANG变量修改成下面这一行：</p>
<pre><code><span class="constant">LANG</span>=<span class="string">"zh_CN.UTF-8"</span>
</code></pre><h1 id="总结">总结</h1>
<p>本文主要总结了Linux系统起初的一些主要且简单的配置和技巧，适合初学者。有了 yum 以后，很多东东都变的简单起来，有更多的时间思考别的，但缺点是必须在线，生产环境下一般都是离线操作，后期有空写个如何搭建 yum 镜像。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="引言">引言</h1>
<p>Linux有很多分支，CentOS、Ubuntu…<br>本文以CentOS-6.4-x86_64环境介绍当我们拿到一个Linux系统，我们需要做的一些主要配置。<br>]]>
    
    </summary>
    
      <category term="linux" scheme="http://xingxiudong.com/tags/linux/"/>
    
      <category term="centos" scheme="http://xingxiudong.com/tags/centos/"/>
    
      <category term="linux" scheme="http://xingxiudong.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新的开始]]></title>
    <link href="http://xingxiudong.com/2014/09/19/new-start/"/>
    <id>http://xingxiudong.com/2014/09/19/new-start/</id>
    <published>2014-09-19T01:41:32.000Z</published>
    <updated>2014-10-14T03:25:05.000Z</updated>
    <content type="html"><![CDATA[<p>前几日在网上无意中看到了<a href="http://hexo.io/index.html" target="_blank" rel="external">hexo</a>，有一种别样的感觉和欣喜，于是，一直存在的想法将<a href="http://blog.csdn.net/xxd851116" target="_blank" rel="external">CSDN的博客</a>迁移到静态博客终于开始浮出水面了。</p>
<p>记得08年就在CSDN开博客，后来慢慢开始觉得不太喜欢，CSDN广告、不灵活、无法自定义HTML、不支持markdown感到不满意，苦一直没有好的方式就没有动手。</p>
<p>经过仔细斟酌后，<a href="http://wordpress.org/" target="_blank" rel="external">wordpress</a>、<a href="http://www.octopress.cn/" target="_blank" rel="external">octopress</a>、<a href="http://www.opoopress.com/zh/" target="_blank" rel="external">opoopress</a>、<a href="http://blog.getpelican.com/" target="_blank" rel="external">pelican</a>都没有考虑使用，最后还是使用了hexo。他们之间的比较百度谷歌一大堆。</p>
<a id="more"></a>

<p>关于hexo的中文文档更是到处都是，不作相关说明。看到了hexo+github的方案后马上就有了答案。对hexo爱不释手！</p>
<p>hexo上手特别快，简单、简洁，在使用的过程中问题直观，且排查容易。hexo是nodejs开发的，后期可借这个力把nodejs摸摸。</p>
<p>以前的csdn博客转移过来可能还需要一些时间，没有在网上找到html转markdown的好的解决方案。打算后期有时间再一点一点的转。</p>
<p>域名考虑了很久，还是用我的名字吧。想太多没用！</p>
<p>给自己一个目标：坚决不作转载，提高原创品质！</p>
<p>总之，哥今天正式搬家啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几日在网上无意中看到了<a href="http://hexo.io/index.html" target="_blank" rel="external">hexo</a>，有一种别样的感觉和欣喜，于是，一直存在的想法将<a href="http://blog.csdn.net/xxd851116" target="_blank" rel="external">CSDN的博客</a>迁移到静态博客终于开始浮出水面了。</p>
<p>记得08年就在CSDN开博客，后来慢慢开始觉得不太喜欢，CSDN广告、不灵活、无法自定义HTML、不支持markdown感到不满意，苦一直没有好的方式就没有动手。</p>
<p>经过仔细斟酌后，<a href="http://wordpress.org/" target="_blank" rel="external">wordpress</a>、<a href="http://www.octopress.cn/" target="_blank" rel="external">octopress</a>、<a href="http://www.opoopress.com/zh/" target="_blank" rel="external">opoopress</a>、<a href="http://blog.getpelican.com/" target="_blank" rel="external">pelican</a>都没有考虑使用，最后还是使用了hexo。他们之间的比较百度谷歌一大堆。</p>
]]>
    
    </summary>
    
      <category term="感悟" scheme="http://xingxiudong.com/categories/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Centos6.5使用yum安装mysql——快速上手必备]]></title>
    <link href="http://xingxiudong.com/2014/04/04/centos6.5-yum-install-mysql/"/>
    <id>http://xingxiudong.com/2014/04/04/centos6.5-yum-install-mysql/</id>
    <published>2014-04-04T09:04:08.000Z</published>
    <updated>2015-01-05T07:25:48.000Z</updated>
    <content type="html"><![CDATA[<p>如果CentOS可以上网，使用yum安装Mysql非常简单，整理了一些日常常用安装Mysql起步配置。<br><a id="more"></a></p>
<h1 id="第1步、yum安装mysql">第1步、yum安装mysql</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install mysql-server</div></pre></td></tr></table></figure>

<p>安装结果：</p>
<p>Installed:<br>mysql-server.x86_64 0:5.1.73-3.el6_5  </p>
<p>Dependency Installed:<br>mysql.x86_64 0:5.1.73-3.el6_5<br>perl-DBD-MySQL.x86_64 0:4.013-3.el6<br>perl-DBI.x86_64 0:1.609-4.el6  </p>
<h1 id="第2步、设置开机启动">第2步、设置开机启动</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chkconfig mysqld on</div></pre></td></tr></table></figure>

<h1 id="第3步、启动MySql服务">第3步、启动MySql服务</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysqld start</div></pre></td></tr></table></figure>

<h1 id="第4步、设置MySQL的root用户设置密码">第4步、设置MySQL的root用户设置密码</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">mysql</span> -u root</div></pre></td></tr></table></figure>

<p>Welcome to the MySQL monitor. &nbsp;Commands end with ; or \g.<br>…… 省略了一些行<br>mysql&gt; select user,host,password from mysql.user;</p>
<p>查询用户的密码，都为空，用下面的命令设置root的密码为root<br>mysql&gt; set password for root@localhost=password(‘root’);<br>mysql&gt; exit</p>
<h1 id="第5步、用新密码登陆">第5步、用新密码登陆</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">mysql</span> -u root -p</div></pre></td></tr></table></figure>

<h1 id="第6步、基本命令">第6步、基本命令</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>show databases;</td>
<td>查看系统已存在的数据库</td>
</tr>
<tr>
<td>use databasesname;</td>
<td>选择需要使用的数据库</td>
</tr>
<tr>
<td>drop database databasename;</td>
<td>删除选定的数据库</td>
</tr>
<tr>
<td>exit</td>
<td>退出数据库的连接</td>
</tr>
<tr>
<td>create database test01;</td>
<td>建立名为test的数据库</td>
</tr>
<tr>
<td>show tables;</td>
<td>列出当前数据库下的表</td>
</tr>
</tbody>
</table>
<p>其他基本的增删改查使用标准SQL即可</p>
<h1 id="第7步、开放远程登录权限">第7步、开放远程登录权限</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'root'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span>  </div><div class="line"><span class="operator"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span></div></pre></td></tr></table></figure>

<p>（完）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果CentOS可以上网，使用yum安装Mysql非常简单，整理了一些日常常用安装Mysql起步配置。<br>]]>
    
    </summary>
    
      <category term="database" scheme="http://xingxiudong.com/tags/database/"/>
    
      <category term="mysql" scheme="http://xingxiudong.com/tags/mysql/"/>
    
      <category term="yum" scheme="http://xingxiudong.com/tags/yum/"/>
    
      <category term="mysql" scheme="http://xingxiudong.com/categories/mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Oracle工作起步：创建表空间、用户及给用户授权SQL和模板]]></title>
    <link href="http://xingxiudong.com/2013/12/28/oracle-create-tablespace-and-grant/"/>
    <id>http://xingxiudong.com/2013/12/28/oracle-create-tablespace-and-grant/</id>
    <published>2013-12-28T04:35:00.000Z</published>
    <updated>2015-01-05T07:24:04.000Z</updated>
    <content type="html"><![CDATA[<p>在工作中我们经常用到Oracle作为生产数据库，对老程序员来说，一个新的项目总是要做一些Oracle数据库初始化的事情，不总结一下对不起这么多年的Oracle使用经验。<br><a id="more"></a></p>
<h1 id="一、规划">一、规划</h1>
<p>表空间名称：yourname<br>表空间数据文件存放位置：/u01/app/oracle/oradata/orcl/（select file_name from dba_data_files;）<br>用户名/密码：yourname/yourname<br>说明：表空间名称、用户名、密码开发时因便于记忆一般一致，默认为项目的名称，也可以不同。</p>
<p><strong><strong><strong><em>**</em></strong></strong></strong> 替换下面的 yourname <strong><strong><strong><em>**</em></strong></strong></strong></p>
<h1 id="二、创建临时表空间">二、创建临时表空间</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLESPACE</span> <span class="string">"temp_yourname"</span></span></div><div class="line">    TEMPFILE <span class="string">'/u01/app/oracle/oradata/orcl/temp_yourname.dbf'</span></div><div class="line">    <span class="keyword">SIZE</span> <span class="number">20</span>M</div><div class="line">AUTOEXTEND <span class="keyword">ON</span></div><div class="line"><span class="keyword">NEXT</span> <span class="number">32</span>M MAXSIZE <span class="number">2048</span>M</div><div class="line">EXTENT MANAGEMENT <span class="keyword">LOCAL</span>;</div></pre></td></tr></table></figure>

<p>注:</p>
<ol>
<li>一般数据库实例安装完成后默认有临时表空间“TEMP”，如果小型数据库用此临时表空间即可。</li>
<li>临时表空间主要用来做查询和存放一些缓冲区数据，消耗的主要原因是需要对查询的中间结果进行排序。主要作用：索引create/rebuild/Order by/group by/Distinct/Union/intersect/minus/Sort-merge/joins等。</li>
<li>TEMPFILE是单引号，否则会报“ORA-00972: identifier is too long”。</li>
<li>TABLESPACE的双引号中的名称一定要全大写字符，否则在创建用户时会报“ORA-00959: tablespace ‘temp_yourname’ does not exist”。</li>
</ol>
<h1 id="三、创建用户表空间">三、创建用户表空间</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">"yourname"</span></span></div><div class="line">    LOGGING</div><div class="line">    DATAFILE <span class="string">'/u01/app/oracle/oradata/orcl/yourname.dbf'</span></div><div class="line">    <span class="keyword">SIZE</span> <span class="number">20</span>M</div><div class="line">AUTOEXTEND <span class="keyword">ON</span></div><div class="line"><span class="keyword">NEXT</span> <span class="number">32</span>M MAXSIZE UNLIMITED</div><div class="line">EXTENT MANAGEMENT <span class="keyword">LOCAL</span>;</div></pre></td></tr></table></figure>

<p>注:</p>
<ol>
<li>DATAFILE是单引号，否则会报“ORA-00972: identifier is too long”。</li>
<li>TABLESPACE的双引号中的名称一定要全大写字符，否则在创建用户时会报“ORA-00959: tablespace ‘yourname’ does not exist”。</li>
</ol>
<h1 id="四、创建用户（并指定默认表空间）">四、创建用户（并指定默认表空间）</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">USER</span> yourname <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> yourname</span></div><div class="line"><span class="keyword">DEFAULT</span> <span class="keyword">TABLESPACE</span> yourname</div><div class="line"><span class="keyword">TEMPORARY</span> <span class="keyword">TABLESPACE</span> temp_yourname;</div></pre></td></tr></table></figure>

<h1 id="五、给用户授权">五、给用户授权</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">GRANT</span> <span class="keyword">connect</span>, resource, dba <span class="keyword">TO</span> yourname;</span></div></pre></td></tr></table></figure>

<h1 id="六、高级用法：创建、使用PL/SQL模板">六、高级用法：创建、使用PL/SQL模板</h1>
<ol>
<li>新建：工具 -&gt; 模板列表 ，右击 -&gt; “新模板”…粘贴模板文件源码。</li>
<li>使用：新建SQL窗口 -&gt; 双击模板 -&gt; 输入参数，修改默认值如下图：<br><img src="/images/20131218-sqltemplete-init.png" alt="编辑模板参数"></li>
<li>生成SQL代码<br><img src="/images/20131218-sqltemplete-gen.png" alt="生成SQL代码"></li>
</ol>
<p>（完）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在工作中我们经常用到Oracle作为生产数据库，对老程序员来说，一个新的项目总是要做一些Oracle数据库初始化的事情，不总结一下对不起这么多年的Oracle使用经验。<br>]]>
    
    </summary>
    
      <category term="oracle" scheme="http://xingxiudong.com/tags/oracle/"/>
    
      <category term="oracle" scheme="http://xingxiudong.com/categories/oracle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[回首2013 —— 2013年我学到的]]></title>
    <link href="http://xingxiudong.com/2013/12/27/looking-back-to-2013/"/>
    <id>http://xingxiudong.com/2013/12/27/looking-back-to-2013/</id>
    <published>2013-12-27T02:25:21.000Z</published>
    <updated>2014-09-30T05:44:00.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>用一种平和的心态面对生活</li>
<li>不能把钱看得太重</li>
<li>最幸福的不仅仅是挣钱，和家人在一起能抚慰我的心灵</li>
<li>和朋友相处要坦诚，为人和&#34108;</li>
<li>有空多喝别人沟通，能获得更多的信息<a id="more"></a></li>
<li>把你认识的人都想成是好人，因为他们真是好人，人以类聚</li>
<li>不要和别人比，幸福源自你对生活的热爱，而不是对money的追随</li>
<li>团队很重要，塑造一个高效的团队还需要多学学管理</li>
<li>不适合做市场、做业务，也不喜欢，兴趣更不在那里</li>
<li>关系在合作中很重要，若&#20284;合同门槛，但产品的交付还是要靠踏实做事</li>
<li>努力工作，认真做事，是你当下工作的方向</li>
<li>合理的跳槽便于市场人才的流动和自身的发展</li>
<li>要以一种坦诚的心面对团队成员</li>
<li>不在团队成员面前表现自己忧虑、忐忑、急躁，这样会让他们感觉你不自信</li>
<li>忌讳和团队成员讨论你觉得影响团队的话题</li>
<li>多和团队成员沟通，工作中有时间就他们的位子坐坐，他们会有问题求助于你，也能拉近你们之间的距离</li>
<li>遇到问题不能逃避，第一时间和团队成员真诚的沟通，告诉他们你真实的想法，他们会理解的</li>
<li>做事要有计划，先打个草稿</li>
<li>不能不考虑团队的利益</li>
<li>项目一定要有清晰的目标，短期和长期，因为这样能让你立场坚定，话语有分量</li>
<li>做事不能急躁，一步一个脚印，要踏实</li>
<li>有很多项目都是客户“没需求”，原型出来后又“有需求”，我们没有一种良好的应对机制，更不能急于求成</li>
<li>工作中不能完全墨守成规，也要适当的按照自己的兴趣有些创新</li>
<li>要有胆量去挑战高度，往往接近终点的时候最难爬，但坚持你就一定能达到</li>
<li>要有认识自己的能力，知难而退</li>
<li>多思考你的工作环境，多利用你的人际网，机会就在不经意之间</li>
<li>不要在你冲动的时候下决定</li>
<li>工作上可能影响家庭的事情要和人家多沟通</li>
<li>不能人云亦云，低调是一种修养</li>
<li>maven的软件生命周期和依赖管理是一种理念</li>
<li>oracle在linux（centos）上安装也要用xwindow图形界面</li>
<li>原来HTTP有长连接</li>
<li>Tomcat比Resin用起来更简单</li>
<li>jQuery的.bind()、.live()和.delegate()事件代理很强大</li>
<li>去思科的面试让我觉得做技术不是没有方向</li>
<li>习惯做技术笔记，对自己和他人都有好处</li>
<li>如果技术上（模块或功能）你实现的很复杂，很有可能方法不对</li>
<li>简化复杂问题，把复杂的东西描述得简单，是一种本事</li>
<li>技术很重要，是自信的筹码</li>
<li>你还很年轻，还有时间做你喜欢做的事</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>用一种平和的心态面对生活</li>
<li>不能把钱看得太重</li>
<li>最幸福的不仅仅是挣钱，和家人在一起能抚慰我的心灵</li>
<li>和朋友相处要坦诚，为人和&#34108;</li>
<li>有空多喝别人沟通，能获得更多的信息]]>
    
    </summary>
    
      <category term="感悟" scheme="http://xingxiudong.com/categories/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第九章 代码风格]]></title>
    <link href="http://xingxiudong.com/2012/07/03/javascript-the-good-parts-reading-notes-ch9/"/>
    <id>http://xingxiudong.com/2012/07/03/javascript-the-good-parts-reading-notes-ch9/</id>
    <published>2012-07-03T14:38:30.000Z</published>
    <updated>2015-01-05T07:25:22.000Z</updated>
    <content type="html"><![CDATA[<p>9.1、我们为什么要按照严格的编码规范来编码？</p>
<ol>
<li>JavaScript是一门弱类型语言，并且它过度的容错。</li>
<li>优秀的程序拥有一个前瞻性的结构，它会遇见未来所需要的可能修改，但不会让其成为过度的负担。</li>
<li>可读性强，便于维护、修改或复制。<a id="more"></a>

</li>
</ol>
<p>9.2、K&amp;R 代码风格：印在Kernighan 与 Ritchie 合著的《The C Programming Language》一书中广泛采用而得名。它是 C 语言的代码风格。</p>
<p>9.3、把 { 放在一行的结尾而不是下一行的开头，因为return的原因。</p>
<p>9.4、注释就像一个时间机器，我用它发送重要的信息给未来的我。</p>
<p>9.5、努力保持注释是最新的。</p>
<p>9.6、尽量不用类似如下这样无用注释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>; <span class="comment">// 设置 i 为 0.</span></div></pre></td></tr></table></figure>


<p>9.7、尽量使用含注释。</p>
<h2 id="总结">总结</h2>
<p>这一章节很不符合中国人的阅读习惯，因为需要仔细逐句理解再总结。个人感觉这篇文章<a href="http://www.ruanyifeng.com/blog/2012/04/javascript_programming_style.html" target="_blank" rel="external">《Javascript编程风格》</a>总结的不错。</p>
<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>9.1、我们为什么要按照严格的编码规范来编码？</p>
<ol>
<li>JavaScript是一门弱类型语言，并且它过度的容错。</li>
<li>优秀的程序拥有一个前瞻性的结构，它会遇见未来所需要的可能修改，但不会让其成为过度的负担。</li>
<li>可读性强，便于维护、修改或复制。]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第八章 方法]]></title>
    <link href="http://xingxiudong.com/2012/07/02/javascript-the-good-parts-reading-notes-ch8/"/>
    <id>http://xingxiudong.com/2012/07/02/javascript-the-good-parts-reading-notes-ch8/</id>
    <published>2012-07-02T14:25:30.000Z</published>
    <updated>2015-01-05T07:25:19.000Z</updated>
    <content type="html"><![CDATA[<p>8.1、Array<br>array.concat(item…)，返回一个新数组（浅拷贝），是由把指定的所有参数添加到array中构成的。  </p>
<blockquote>
<p>注1：可有1个或多个参数，如果参数是数组，数组的每个元素会被分别添加。<br>注2：它不修改array，返回的是一个新数组。<br><a id="more"></a></p>
</blockquote>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.concat(<span class="number">4</span>,[<span class="number">5</span>, [<span class="number">6</span>,<span class="number">7</span>]]);    <span class="comment">// Returns [1,2,3,4,5,[6,7]]  </span></div><div class="line">array.join(separator)，返回一个字符串，用 separator 分隔符把它们连接在一起。默认分隔符是半角逗号<span class="string">','</span>。</div><div class="line">array.pop()，返回 array 中最后一个元素，并移除它，数组长度减<span class="number">1</span>。</div></pre></td></tr></table></figure>

<p>注：如果 array 是空的，则不改变 array，返回undefined。<br>例子：<br>方法pop()和它的伴随方法push()可以提供先进后出(FILO)栈的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stack = [];    <span class="comment">// stack: []  </span></div><div class="line">stack.push(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// stack: [1,2]    Return 2  </span></div><div class="line">stack.pop();       <span class="comment">// stack: [1]    Return 1  </span></div><div class="line">stack.push(<span class="number">4</span>, <span class="number">5</span>);  <span class="comment">// stack: [1,[4,5]]    Return 2  </span></div><div class="line">stack.pop();       <span class="comment">// stack: [1]    Return [4,5]  </span></div><div class="line">stack.pop();       <span class="comment">// stack: []    Return 1</span></div></pre></td></tr></table></figure>

<p><strong>array.push(item…)</strong>，返回 push 后新数组的长度，它将一个或多个参数 item 附加到 array 的尾部。<br>注1：该方法不创建新的数组，而是直接修改原有的array。<br>注2：如果 item 是数组，会将参数数组作为单个元素添加之（此与concat不同）。<br><strong>array.reverse()</strong>，返回反转后的 array 数组。<br>注1：它在原数组上实现这一操作作为替代：重排指定的array的元素，但并不创建新数组。<br>注2：如果对array有多个引用，那么通过所有引用都可以看到数组元素的新顺序。<br><strong>array.shift()</strong>，返回 array 中第一个元素，并移除它，并且将余下的所有元素前移一位，以填补数组头部的空缺。<br>注1：如果 array 是空的，将不进行任何操作，返回undefined。<br>注2：shift 通常比 pop 慢很多。<br>注3：该方法不创建新的数组，而是直接修改原有的array。<br><strong>array.slice(start, end)</strong>，返回一个浅复制后的新数组（不包括array[end]元素）。它对 array 中的一段作浅复制，第一个被复制的元素是 array[start]，一直复制到 array[end]。<br>注1：start如果是负数，为从数组尾部开始算起的位置。也就是说-1指最后一个元素，-2指倒数第二个元素，以此类推。<br>注2：end如果没有指定，默认为 array.length，即切分的数组包含从start开始到数组结束的所有元素。如果这个参数是负数，它声明的是从数组尾部开始算起的元素。<br>注3：返回的新数组不包括array[end]。<br>注4：如果 start 大于 array.length，返回一个空数组。<br>注5：该方法并不修改数组。如果想删除数组中的一段元素，应该使用方法Array.splice()。<br>注6：在Internet Explorer 4中，参数start不能为负数。这在IE的最新版本中已经更正。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];  </div><div class="line">a.slice(<span class="number">0</span>,<span class="number">3</span>);    <span class="comment">// Return [1,2,3]  </span></div><div class="line">a.slice(<span class="number">3</span>);    <span class="comment">// Return [4,5]  </span></div><div class="line">a.slice(<span class="number">1</span>,-<span class="number">1</span>);    <span class="comment">// Return [2,3,4]  </span></div><div class="line">a.slice(-<span class="number">3</span>,-<span class="number">2</span>);    <span class="comment">// Return [3]; buggy in IE 4: return [1,2,3]</span></div></pre></td></tr></table></figure>

<p><strong>array.sort(compareFn)</strong>，对数组 array 的内容按比较函数进行排序，它不能正确地给一组数字进行排序。<br>注1：javascript默认的比较函数假定所有要被排序的元素都是字符串，所以比较的时候会将其先转化成字符串；<br>注2：比较函数接受两个参数，如果两个参数相等则返回0，如果第一个参数应该排列在前面，则返回一个负数，如果第二个参数应该排列在前面，则返回一个正数。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];  </div><div class="line">n.sort(); <span class="comment">// n 是 [15, 16, 23, 4, 42, 8]  </span></div><div class="line">n.sort(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{  </div><div class="line"><span class="keyword">return</span> a - b;  </div><div class="line">});  </div><div class="line"><span class="comment">// n 是 [4, 8, 15, 16, 23, 42];</span></div></pre></td></tr></table></figure>

<p><strong>array.splice(start, deleteCount, item…)</strong>，从数组 array 中删除1个或多个元素，并用心的item代替它们。返回一个包含移除元素的数组。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];  </div><div class="line"><span class="keyword">var</span> r = a.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'ache'</span>, <span class="string">'bug'</span>);  </div><div class="line"><span class="comment">// a 是 ['a', 'ache', 'bug', 'c'];  </span></div><div class="line"><span class="comment">// r 是 ['b'];</span></div></pre></td></tr></table></figure>

<p><strong>array.unshift(item…)</strong>，像 push 方法一样用于将元素添加到数组中，但它是把 item 插入到 array 的开始部分而不是尾部。它返回 array 的新的长度值。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]; <span class="comment">// a 是 ['?', '@', 'a', 'b', 'c']  </span></div><div class="line"><span class="keyword">var</span> r = a.unshift(<span class="string">'?'</span>, <span class="string">'@'</span>); <span class="comment">// r 是5</span></div></pre></td></tr></table></figure>

<p>8.2、Function<br><strong>function.apply(thisArg, argArray)</strong>，此方法调用函数 function，传递一个将被绑定到 this 上的对象和一个可选的参数数组。apply 方法被用在 apply 调用模式中。</p>
<p>8.3、Number<br><strong>number.toExponential(fractionDigits)</strong>，把 number 转换成一个指数形式的字符串。 可选参数 fractionDigits 控制其小数点后的数字位数。它的值必须在 0 至 20 之间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toExponential(<span class="number">0</span>)); <span class="comment">// 3e+0  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toExponential(<span class="number">2</span>));  <span class="comment">// 3.14e+0  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toExponential(<span class="number">7</span>));  <span class="comment">// 3.1415927e+0  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toExponential(<span class="number">16</span>)); <span class="comment">// 3.1415926535897930e+0  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toExponential());  <span class="comment">// 3.141592653589793e+0</span></div></pre></td></tr></table></figure>

<p><strong>number.toFiexd(fractionDigits)</strong>，把 number 转换成一个十进制数形式的字符串。可选参数 fractionDigits 控制其小数点后的数字位数。它的值必须在 0 至 20 之间。默认为0：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toFixed(<span class="number">0</span>)); <span class="comment">// 3  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toFixed(<span class="number">2</span>));  <span class="comment">// 3.14  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toFixed(<span class="number">7</span>));  <span class="comment">// 3.1415927  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toFixed(<span class="number">16</span>)); <span class="comment">// 3.1415926535897930  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toFixed());  <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<p><strong>number.toPrecision(precision)</strong>，把 number 转换成一个十进制形式的字符串。可选参数 precision 控制有效数字的位数。它的值必须在 0 到 21 之间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toPrecision(<span class="number">2</span>));  <span class="comment">// 3.1   </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toPrecision(<span class="number">7</span>));  <span class="comment">// 3.141593   </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toPrecision(<span class="number">16</span>)); <span class="comment">// 3.141592653589793   </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toPrecision());  <span class="comment">// 3.141592653589793</span></div></pre></td></tr></table></figure>

<p><strong>number.toString(radix)</strong>，将 number 转换成一个字符串。可选参数 radix 是控制基数。它的值必须在 2 和 36 之间。默认 radix 是以 10 为基数的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toString(<span class="number">2</span>));  <span class="comment">// 11.001001000011111101101010100010001000010110100011  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toString(<span class="number">8</span>));  <span class="comment">// 3.1103755242102643   </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toString(<span class="number">16</span>)); <span class="comment">// 3.243f6a8885a3  </span></div><div class="line"><span class="built_in">document</span>.writeln(<span class="built_in">Math</span>.PI.toPrecision());  <span class="comment">// 3.141592653589793</span></div></pre></td></tr></table></figure>

<p>8.4、Object<br><strong>object.hasOwnProperty(name)</strong>，如果这个 object 包含了一个名为 name 的属性，返回 true。<br>注1：原型链中同名属性是不会被检查的。<br>注2：对 name 就是 hasOwnProperty 时不起作用， 此时会返回 false。</p>
<p>8.5、RegExp<br><strong>regexp.exec(string)</strong>，exec 方法使用正则表达式的最强大（和最慢）的方法。如果它成功地匹配 regexp 和字符串 string，它会返回一个数组。数组中下标为 0 的元素将包含正则表达式 regexp 匹配的子字符串。下标为 1 的元素是分组 1 捕获的文本，下标为 2 的元素是分组 2 捕获的文本，以此类推。如果匹配失败，返回 null。<br><strong>regexp.test(string)</strong>，test 方法使用正则表达式的最简单（和最快）的方法。如果它成功地匹配 regexp 和字符串 string，它返回 true。不要对这个方法使用 g 标识。</p>
<p>8.6、String<br><strong>string.charAt(pos)</strong>，返回在 string 中 pos 位置处的字符。pos 小于 0 或大于等于字符串的长度，返回空字符串。<br><strong>string.charCodeAt(pos)</strong>，返回在 string 中 pos 位置处的字符码位。pos 小于 0 或大于等于字符串的长度，返回NaN。<br><strong>string.indexOf(searchString, position)</strong>，在 string 中查找另一个字符串 searchString。如果它被找到，则返回第一个被匹配字符的位置，否则返回-1。position 表示查找的起始位置。<br><strong>string.lastIndexOf(searchString, position)</strong>，与 indexOf 方法类型，但它是从该字符串的末尾开始查找。<br><strong>string.localeCompare(that)</strong>，比较两个字符串。如果 string 比 that 小，结果为负数。如果他们相等，结果为0。<br><strong>string.match(regexp)</strong>，它匹配一个字符串和一个正则表达式。它依据 g 标识来决定如何进行匹配。如果没有 g 表示，那么调用 string.match(regexp) 的结果与调用 regexp.exec(string)的结果相同。然而，如果 regexp 带有一个 g 标识，那么它返回一个包含除捕获分组之外的所有匹配的数组。<br><strong>string.replace(searchValue, replaceValue)</strong>，对 string 进行查找和替换操作，并返回一个新的字符串。<br>注1：searchValue 可以是一个字符串或一个正在表达式。<br>注2：如果 searchValue 是一个正则表达式并且带有 g 标志，那么它将替换所有匹配之处。如果没有，仅替换第一个匹配之处。<br>注3：replaceValue 可以是一个字符串或一个函数。如果 replaceValue 是一个字符串，字符 $ 拥有特别的含义：  </p>
<ol>
<li>$$:　　　　　$</li>
<li>$&amp;:　　　　　整个匹配的文本</li>
<li>$number:　　分组捕获的文本 </li>
<li>$`：　　　  　匹配之前的文本</li>
<li>$’：　　　　  匹配之后的文本   </li>
</ol>
<p>如果 replaceValue 是一个函数，此方法将对每个匹配依次调用它，并且该函数返回的字符串将被用作替换的文本。传递给这个函数的第一个参数是整个被匹配的文本。第二个参数是分组 1 捕获的文本，下一个参数是分组 2 捕获的文本，以此类推。<br><strong>string.slice(start, end)</strong>，slice 方法复制 string 的一部分来构造一个新的字符串。<br>注1：如果 start 参数是负数，它将与 string.length 相加。<br>注2：end参数是可选的，它的默认值是 string.length。<br>注3：如果 end 参数是负数，它将与 string.length 相加。<br><strong>string.split(separator, limit)</strong>，split 方法把这个 string 分隔成片段来创建一个字符串数组。<br>注1：limit 可以限制被分割的片段数量。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> digits = <span class="string">'0123456789'</span>;  </div><div class="line"><span class="keyword">var</span> a = digits.split(<span class="string">''</span>, <span class="number">5</span>);  </div><div class="line"><span class="comment">// a 是 ['0', '1', '2', '3', '456789']</span></div></pre></td></tr></table></figure>

<p>注2：separator 参数可以是一个字符串或一个正则表达式。<br><strong>string.substring(start, end)</strong>，和 slice 方法一样，只是它不能处理负数参数。没有任何理由使用 substring 方法，建议用 slice 替代。<br><strong>string.toLocaleLowerCase()</strong>，返回一个使用本地化规则把 string 中的所有字母转换为小写格式。<br>注：这个方法主要用在土耳其语上，因为在土耳其语中’I’转换为’1’，而不是’i’。<br><strong>string.toLocaleUpperCase()</strong>，返回一个使用本地化规则把 string 中的所有字母转换为大写格式。也是主要用在土耳其语上。<br><strong>string.toLowerCase()</strong>，返回一个所有字母都变为小写的新字符串。<br><strong>string.toUpperCase()</strong>，返回一个所有字母都变为大写的新字符串。<br><strong>string.fromCharCode(char…)</strong>，从一串数字中返回一个字符串。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">String</span>.fromCharCode(<span class="number">67</span>, <span class="number">97</span>, <span class="number">116</span>); <span class="comment">// a 是 'Cat'</span></div></pre></td></tr></table></figure>



<h2 id="小结">小结</h2>
<p>这一章中主要介绍了JavaScript中6大对象基本所拥有的基本方法，比较系统，也枯燥无味！</p>
<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>8.1、Array<br>array.concat(item…)，返回一个新数组（浅拷贝），是由把指定的所有参数添加到array中构成的。  </p>
<blockquote>
<p>注1：可有1个或多个参数，如果参数是数组，数组的每个元素会被分别添加。<br>注2：它不修改array，返回的是一个新数组。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第七章 正则表达式]]></title>
    <link href="http://xingxiudong.com/2012/06/19/javascript-the-good-parts-reading-notes-ch7/"/>
    <id>http://xingxiudong.com/2012/06/19/javascript-the-good-parts-reading-notes-ch7/</id>
    <published>2012-06-18T16:32:30.000Z</published>
    <updated>2015-01-05T07:25:14.000Z</updated>
    <content type="html"><![CDATA[<p>7.1、在JavaScript中，正则表达式是对Perl版的改进和发展。</p>
<p>7.2、^ 表示一个字符串的开始，$表示一个字符串的结束。</p>
<p>7.3、(?: …) 表示一个非捕获型分组（noncapturing group）。</p>
<p>7.4、( … ) 表示一个捕获型分组（capturing group）。</p>
<p>7.5、[…] 表示一个字符类，[^?#] 表示一个字符类包含除 ? 和 # 之外的所有字符。<br><a id="more"></a></p>
<p>7.6、有两个方法来创建RegExp对象。优先采用正则表达式字面量。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> my_regexp = <span class="regexp">/"(?:\\.|[^\\\"])*"/g</span>;</div></pre></td></tr></table></figure>

<p>但如果要使用RegExp构造器创建一个正则表达式，要多加小心，因为反斜杠在正则表达式和在字符串字面量中有不同的含义。通常需要双写反斜杠及对引号进行转义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> my_regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\"(?:\\.|[^\\\\\\\"])*\""</span>, <span class="string">'g'</span>);</div></pre></td></tr></table></figure>

<p>7.7、在RegExp中，有三个标志：g、i和m。</p>
<p>7.8、RegExp对象的属性  </p>
<!--
| 属性       | 用法 |
| -----:     | :----  |
| global     | 如果标志 g 被使用，值为 true |
| ignoreCase | 如果标志 i 被使用，值为 true |
| lastIndex  | 下一次 exec 匹配开始的索引。初始值为 0 |
| multiline  | 如果 m 被使用，值为 true |
| source     | 正则表达式源代码文本 | -->

<ul>
<li>global: 如果标志 g 被使用，值为 true</li>
<li>ignoreCase: 如果标志 i 被使用，值为 true</li>
<li>lastIndex: 下一次 exec 匹配开始的索引。初始值为 0</li>
<li>multiline: 如果 m 被使用，值为 true</li>
<li>source: 正则表达式源代码文本</li>
</ul>
<p>7.9、一个正则表达式因子可以是一个字符、一个由圆括号包围的组、一个字符类，或者是一个转义序列。除了控制字符和特殊字符以外，所有的字符都将被按照字面处理：<br>\ / [ ] ( ) { } ? + * | . ^ $<br>如果上面列出的字符按字面去【匹配，那么必须要一个 \ 前缀来进行转移。</p>
<p>7.10、正则表达式转义：</p>
<ul>
<li>\f是换页符，\n是换行符，\r是回车符，\t是制表符，\u允许指定一个Unicode字符来表示一个十六进制的常量</li>
<li>\d 等同于 [0-9]</li>
<li>\s 等同于 [\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]。这是Unicode空白符的一个不完全子集。\S表示与其相反的：[^\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</li>
<li>\w 等同于 [0-9A-Z_a-z]。\W则表示与其相反。</li>
<li>\b 被指定为一个字的边界标志。</li>
<li>\1 是指分组 1 所捕获到的文本的一个引用，\2指向分组2的引用，\3指向分组3的引用，以此类推。</li>
</ul>
<p>7.11、正则表达式分组共有4种：捕获型、非捕获型、向前正向匹配和向前负向匹配。</p>
<p>7.12、正则表达式字符类内部的转义规则和正则表达式因子相比稍有不同。[\b]是退格符。下面是在字符类中需要被转义的特殊字符：<br>　　- / [ \ ] ^</p>
<p>7.13、正则表达式因子可以用一个正则表达式量词后缀，用来决定这个因子应该被匹配的次数。包围在一对花括号中的一个数字表示这个因子应该被匹配的次数。所以，/www/和/w{3}/等价。{3,6}将【匹配3、4、5或6次。{3,}匹配3次或更多次。</p>
<p>7.14、? 等同于 {0,1}。 * 等同于 {0,} + 则等同于 {1,}。</p>
<p>7.15、如果只有一个量词，则趋向于进行贪婪性的匹配，即匹配尽可能多的重复直至达到上限。如果这个量词还有一个额外的后缀?，那么则趋向于进行懒惰性匹配，即试图匹配尽可能少的必要重复。</p>
<h2 id="总结">总结</h2>
<p>本章对正则略感并未深入，关于“捕获分组”即点到为止，也未触及“零宽断言”的概念（一个使用零宽断言的例子——《不包含字符串abc的正则表达式》）。《正则表达式30分钟入门教程》言简意赅地丰富并弥补了这些不足。</p>
<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>7.1、在JavaScript中，正则表达式是对Perl版的改进和发展。</p>
<p>7.2、^ 表示一个字符串的开始，$表示一个字符串的结束。</p>
<p>7.3、(?: …) 表示一个非捕获型分组（noncapturing group）。</p>
<p>7.4、( … ) 表示一个捕获型分组（capturing group）。</p>
<p>7.5、[…] 表示一个字符类，[^?#] 表示一个字符类包含除 ? 和 # 之外的所有字符。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第六章 数组]]></title>
    <link href="http://xingxiudong.com/2012/06/17/javascript-the-good-parts-reading-notes-ch6/"/>
    <id>http://xingxiudong.com/2012/06/17/javascript-the-good-parts-reading-notes-ch6/</id>
    <published>2012-06-17T15:09:30.000Z</published>
    <updated>2015-01-05T07:25:09.000Z</updated>
    <content type="html"><![CDATA[<p>6.1、数组是一段线性分配的内存，它通过整数去计算偏移并访问其中的元素。</p>
<p>6.2、JavaScript 没有数组数据结构。但提供了一种类数组特性的对象。它把数组的下标转变成字符串，用作其属性。</p>
<p>6.3、JavaScript 中这种类“数组特性的对象”与一般对象的不同点在于：</p>
<ol>
<li>此对象继承自Array.prototype，而一般对象继承自Object.prototype；</li>
<li>此对象拥有一个诡异的length属性，而一般对象没有。<a id="more"></a>

</li>
</ol>
<p>6.4、JavaScript中，允许数组包含任意混合类型的值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> misc = [<span class="string">'string'</span>, <span class="number">98.6</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, [<span class="string">'nested'</span>, <span class="string">'array'</span>], {object : <span class="literal">true</span>}, <span class="literal">NaN</span>, <span class="literal">Infinity</span>];  </div><div class="line">misc.length <span class="comment">// 10</span></div></pre></td></tr></table></figure>

<p>6.5、每一个数组都有一个length属性。和大多数其他语言不同，JavaScript数组的length没有上界。</p>
<p>6.6、length 属性的值是这个数组中最大整数属性名加上1，所以它不一定等于数组里属性的个数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [];  </div><div class="line">myArray.length <span class="comment">// 0  </span></div><div class="line">  </div><div class="line">myArray[<span class="number">1000000</span>] = <span class="literal">true</span>;  </div><div class="line">myArray.length <span class="comment">// 1000001  </span></div><div class="line"><span class="comment">// myArray 只包含一个属性</span></div></pre></td></tr></table></figure>

<p>6.7、[] 后缀下标运算符将它的表达式转换成一个字符串，如果该字表达式有toString方法，就是用该方法的值。这个字符串被用作属性名。如果这个字符串看起来像一个大于等于这个数组当前的length且小于4 294 976 295的正整数，那么这个数组的length就会被重新设置成新的下标加1。</p>
<p>6.8、可以手动设置length的值。设置更大无须给数组分配更多的空间，而把length设小，将导致下标大于等于新length的属性被删除。</p>
<p>6.9、由于JavaScript中的数组就是对象，所以delete运算符可以用来从数组中移除元素。不幸的是，这样户在数组中遗留一个空洞。这是因为排在被删除元素之后的元素保留了他们最初的名字（下标）。</p>
<p>6.10、splice方法可以用来删除数组中的一些元素。第一个参数是数组中的序号，第二个参数是要删除元素的个数。此方法对大型数组来说效率不高。</p>
<p>6.11、typeof 运算符报告数组的类型是’Object’，JavaScript数组与对象的区别是混乱的。</p>
<p>6.12、可以通过for in语句来遍历一个数组所有的属性，for in无法保证属性的顺序，而for语句能避免这样的问题。</p>
<p>6.13、一个检查对象是否为数组的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> is_array = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>{  </div><div class="line">    <span class="keyword">return</span> value &&  </div><div class="line">        <span class="keyword">typeof</span> value === <span class="string">'object'</span> &&  </div><div class="line">        <span class="keyword">typeof</span> value.length === <span class="string">'number'</span> &&  </div><div class="line">        <span class="keyword">typeof</span> value.splice === <span class="string">'function'</span> &&  </div><div class="line">        !(value.propertyIsEnumerable(<span class="string">'length'</span>));  </div><div class="line">};</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>JavaScript中的数组并没有数组结构，而是一种类数组的对象。该对象继承自Array.prototype，它多了一个length属性。</p>
<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>6.1、数组是一段线性分配的内存，它通过整数去计算偏移并访问其中的元素。</p>
<p>6.2、JavaScript 没有数组数据结构。但提供了一种类数组特性的对象。它把数组的下标转变成字符串，用作其属性。</p>
<p>6.3、JavaScript 中这种类“数组特性的对象”与一般对象的不同点在于：</p>
<ol>
<li>此对象继承自Array.prototype，而一般对象继承自Object.prototype；</li>
<li>此对象拥有一个诡异的length属性，而一般对象没有。]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第五章 继承]]></title>
    <link href="http://xingxiudong.com/2012/06/17/javascript-the-good-parts-reading-notes-ch5/"/>
    <id>http://xingxiudong.com/2012/06/17/javascript-the-good-parts-reading-notes-ch5/</id>
    <published>2012-06-17T14:31:30.000Z</published>
    <updated>2015-01-05T07:25:06.000Z</updated>
    <content type="html"><![CDATA[<p>5.1、继承的两个作用：1、代码重用；2、类型系统规范。</p>
<p>5.2、JavaScript是一门弱类型的语言。不需要类型转换。对象的起源是无关紧要的。</p>
<p>5.3、JavaScript是一门基于原型的语言，而不是基于类的语言。<br><a id="more"></a></p>
<p>5.4、JavaScript的prototype。<br>当一个函数对象被创建时，Function 构造器产生的函数对象会运行类似这样的一些代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.prototype = { constructor : <span class="keyword">this</span> };</div></pre></td></tr></table></figure>

<p>新函数对象被赋予一个 prototype 属性，其值是包含一个 constructor 属性且属性值为该新函数对象。该 prototype 对象是存放集成特征的地方。因为JavaScript语言没有提供一种方法去确定哪个函数是打算用来作构造器的，所以每个函数都会得到一个prototype对象。</p>
<p>5.5、当采用构造器调用模式，即使用 new 前缀 去调用一个函数时，将修改函数执行方式。</p>
<p>5.6、定义一个构造器，扩充它的原型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Mammal = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>{  </div><div class="line">    <span class="keyword">this</span>.name = name;  </div><div class="line">};  </div><div class="line">Mammal.prototype.get_name = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;  </div><div class="line">};  </div><div class="line">Mamal.prototype.says = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.saying || <span class="string">''</span>;  </div><div class="line">};</div></pre></td></tr></table></figure>

<p>再构造一个实例：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myMammal = <span class="keyword">new</span> Mammal(<span class="string">'Herb the Mamal'</span>);  </div><div class="line"><span class="keyword">var</span> name = myMammal.get_name(); <span class="comment">// 'Herb the Mammal';  </span></div><div class="line"><span class="built_in">document</span>.writeln(name);</div></pre></td></tr></table></figure>

<p>构造一个伪类来继承Mammal，这是通过定义它的constructor函数并替换它的prototype为一个Manmal的实例来实现的：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>{  </div><div class="line">    <span class="keyword">this</span>.name = name;  </div><div class="line">    <span class="keyword">this</span>.saying = <span class="string">'meow'</span>;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 替换 Cat.prototype 为一个新的 Mammal 实例  </span></div><div class="line">Cat.prototype = <span class="keyword">new</span> Mammal();  </div><div class="line"><span class="comment">// 扩充新原型对象，增加 purr 和 get_name 方法  </span></div><div class="line">Cat.prototype.purr = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> </span>{  </div><div class="line">    <span class="keyword">var</span> i, s = <span class="string">''</span>;  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) {  </div><div class="line">        <span class="keyword">if</span> (s) {  </div><div class="line">            s +- <span class="string">'-'</span>;  </div><div class="line">        }  </div><div class="line">        s += <span class="string">'r'</span>;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">return</span> s;  </div><div class="line">};  </div><div class="line">Cat.prototype.get_name  = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.says() + <span class="string">' '</span> + <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.says();  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Cat(<span class="string">'Henrietta'</span>);  </div><div class="line"><span class="keyword">var</span> says = myCat.says(); <span class="comment">// 'meow'  </span></div><div class="line"><span class="keyword">var</span> purr = myCat.purr(<span class="number">5</span>); <span class="comment">// 'r-r-r-r-r'  </span></div><div class="line"><span class="keyword">var</span> name = myCat.get_name(); <span class="comment">// 'meow Henrietta meow'</span></div></pre></td></tr></table></figure>

<p>使用构造器函数存在一个严重的危害。如果在调用构造器函数时忘记了在前面加上 new 前缀，那么 this 将不会被绑定到一个新的对象上，而被绑定到全局对象上，所以不但没有扩充新对象，反而破坏了全局变量。更恶心的是，发生了这样情况时，既没有编译时警告，也没有运行时警告。</p>
<p>这是一个严重的语言设计错误。为了降低这个问题带来的风险，所有的构造器函数都约定命名成首字母大写的形式，并且不以首字母大写的形式拼写任何其他的东西。这样可以通过目视检查去发现是否缺少了 new 前缀。一个更好的备选方案就是根本不使用 new。</p>
<p>5.7、在一个纯粹的原型模式中，会摒弃类而专注于对象。</p>
<p>5.8、使用函数模块模式的应用来解决继承中父类属性私有化的问题。</p>
<h2 id="总结">总结</h2>
<ol>
<li>prototype 对象中有一个 constructor 属性，它指向当前对象的一个引用。</li>
<li>一个不成文的约定，如果替换了prototype对象：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.prototype = {};</div></pre></td></tr></table></figure>

<p>那么，下一步需要为新的 prototype 对象加上 constructor 属性，并将这个属性指回原来的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.prototype.constructor = o;</div></pre></td></tr></table></figure>

<p>原因是前一步已经删除了这个prototype对象原来的值，所以新的prototype对象没有constructor属性，所以我们必须手动加上去，否则后面的“继承链”会出问题。</p>
<blockquote>
<p>这一章个人感觉JavaScript中的继承还是可以理解的，但读起来特别费劲，收藏3篇不错的进阶文章<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">《Javascript 面向对象编程（一）：封装》</a>、<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">《Javascript面向对象编程（二）：构造函数的继承》</a>和<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">《Javascript面向对象编程（三）：非构造函数的继承》</a>。</p>
</blockquote>
<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>5.1、继承的两个作用：1、代码重用；2、类型系统规范。</p>
<p>5.2、JavaScript是一门弱类型的语言。不需要类型转换。对象的起源是无关紧要的。</p>
<p>5.3、JavaScript是一门基于原型的语言，而不是基于类的语言。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第四章 函数]]></title>
    <link href="http://xingxiudong.com/2012/06/16/javascript-the-good-parts-reading-notes-ch4/"/>
    <id>http://xingxiudong.com/2012/06/16/javascript-the-good-parts-reading-notes-ch4/</id>
    <published>2012-06-16T15:34:00.000Z</published>
    <updated>2015-01-05T07:25:01.000Z</updated>
    <content type="html"><![CDATA[<p>4.1、在JavaScript中，函数就是对象。</p>
<p>4.2、函数的对象连接到Function.prototype（该原型对象本身被连接到Object.prototype）。</p>
<p>4.3、函数在创建的时候附有两个附加的隐藏属性：函数上下文和实现函数行为的代码。<br><a id="more"></a></p>
<p>4.4、函数与其它对象的不同之处在于它可以被调用。</p>
<p>4.5、函数对象可以通过函数字面量来创建：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  创建一个名为 add 的变量，并用来把两个数字相机的函数赋值给它。  </span></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> </span>{  </div><div class="line">    <span class="keyword">return</span> a + b;  </div><div class="line">};</div></pre></td></tr></table></figure>


<blockquote>
<p>函数字面量包括四个部分。</p>
<ul>
<li>第一部分是保留字function。</li>
<li>第二部分是函数名，它可以被省略——即“匿名函数”。函数名可以用来递归地调用自己。</li>
<li>第三部分是包围在圆括号中的一组参数。其中每个参数用逗号分隔。</li>
<li>第四部分是包围在花括号中的一组语句。这些语句是函数的主体。它们在函数被调用是执行。</li>
</ul>
</blockquote>
<p>4.6、函数字面量可以出现在任何表达式允许出现的地方，函数也可以被定义在其它函数中。一个内部函数自然可以访问自己的参数和变量，同时它也能方便地访问它被嵌套在其中的那个函数的参数和变量。通过函数字面量创建的函数对象包含一个连接到外部上下文的连接。这被称为“闭包”。它是JavaScript强大表现力的根基。</p>
<p>4.7、调用一个函数将暂停当前函数的执行，传递控制权和参数给新函数。</p>
<p>4.8、除声明时定义的形参，每个函数还接收两个附加的参数：this和arguments。</p>
<p>4.9、参数this的值取决于调用的模式。在JavaScript中一共有四种调用模式：方法调用模式、函数调用模式、构造器调用模式和apply调用模式。</p>
<p>4.10、当实际参数的个数和形式参数的个数不匹配时不会导致运行时错误。如果实际参数值过多，超出的参数值将被忽略。如果实际的参数值过少，缺失的值将会被替换为undefined。</p>
<p>4.11、对参数值不会进行类型检查，任何类型的值都可以被传递给参数。</p>
<p>4.12、方法调用模式：当一个函数被保存为对象的一个属性时，称它为一个“方法”。当一个方法被调用时，this被绑定到该对象。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 myObject。它有一个 value 属性和 increment 方法。  </span></div><div class="line"><span class="comment">// increment 方法接受一个可选的参数。如果参数不是数字，那么默认使用数字1。  </span></div><div class="line">  </div><div class="line"><span class="keyword">var</span> myObject = {  </div><div class="line">    value : <span class="number">0</span>,  </div><div class="line">    increment : <span class="function"><span class="keyword">function</span> <span class="params">(inc)</span> </span>{  </div><div class="line">        <span class="keyword">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">  </div><div class="line">myObject.increment();  </div><div class="line"><span class="built_in">document</span>.writeln(myObject.value); <span class="comment">// 1  </span></div><div class="line">myObject.increment(<span class="number">2</span>);  </div><div class="line"><span class="built_in">document</span>.writeln(myObject.value); <span class="comment">// 3</span></div></pre></td></tr></table></figure>


<p><a href="http://jsfiddle.net/xingxiudong/Amhww/" target="_blank" rel="external">演示Demo</a></p>
<p>4.13、函数调用模式：当一个函数并非一个对象的属性时，那么它被当作一个函数来调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = add(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// sum 的值为 7</span></div></pre></td></tr></table></figure>

<blockquote>
<p>当函数以此模式被调用时，this被绑定到全局对象。这是语言设计上的一个错误。倘若正确，this应该绑定到外部函数的this变量。这个设计错的后果是方法不能利用内部函数来帮助它工作，因为内部函数被绑定了错误的值，所以不能共享该方法对对象的访问权。解决方案是该方法定义一个变量并给它赋值为this。</p>
</blockquote>
<p>4.14、构造器调用模式：如果在一个函数前面带上new来调用，那么将创建一个隐藏连接到该函数的 prototype 成员的新对象，同时 this 将会被绑定到那个新对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个名为 Quo 的构造器函数。它构造一个带有 status 属性的对象。  </span></div><div class="line"><span class="keyword">var</span> Quo = <span class="function"><span class="keyword">function</span> <span class="params">(string)</span> </span>{  </div><div class="line">    <span class="keyword">this</span>.status = string;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 给 Quo 的所有实例提供一个名为 get_status 的公共方法。  </span></div><div class="line">Quo.prototype.get_status = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.status;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 构造一个 Quo 实例  </span></div><div class="line"><span class="keyword">var</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">"confused"</span>);  </div><div class="line"><span class="built_in">document</span>.writeln(myQuo.get_status()); <span class="comment">// 令人困惑</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/xingxiudong/Bv3zz/1/" target="_blank" rel="external">演示Demo</a>  </p>
<blockquote>
<p>注: 作者不推荐这种写法，原因在下章阐述。</p>
<p>4.15、Apply 调用模式：因为 JavaScript 是一门函数式的面向对象编程语言，所以函数可以拥有方法。<br>apply 方法可以构建一个参数数组并勇气去调用函数。它也允许我们选择 this 的值。<br>apply 方法接收两个参数。第一个是将被绑定给 this 的值。第二个就是参数数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造一个包含两个数字的数组，并将它们相加。  </span></div><div class="line"><span class="keyword">var</span> array = [<span class="number">3</span>, <span class="number">4</span>];  </div><div class="line"><span class="keyword">var</span> sum = add.apply(<span class="literal">null</span>, array); <span class="comment">// sum 值为 7  </span></div><div class="line">  </div><div class="line"><span class="comment">// 构造一个包含 status 成员的对象。  </span></div><div class="line"><span class="keyword">var</span> statusObject = {  </div><div class="line">    status : <span class="string">'A-OK'</span>  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// statusObject 并没有继承自 Quo.prototype，但我们可以在 statusObject 上调用 get_status 方法，尽管 statusObject 并没有一个名为 get_status 的方法。  </span></div><div class="line"><span class="keyword">var</span> status = Quo.prototype.get_status.apply(statusObject); <span class="comment">// status 值为 'A-OK'。</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/xingxiudong/6AWsh/" target="_blank" rel="external">演示Demo</a></p>
<p>4.16、函数可以通过 arguments 数组访问所有它被调用时传递给它的参数列表。因为语言的一个设计错误，arguments 并不是一个真正的数组，它只是一个类似数组的对象。arguments 拥有一个 length 属性，但它缺少所有数组的方法。</p>
<p>4.17、一个函数总有一个返回值，如果没有指定则返回 undefined。</p>
<p>4.18、如果函数在前面加上 new 前缀来调用，且返回值不是一个对象，则返回 this （该新对象）。</p>
<p>4.19、throw 语句中断函数的执行。它抛出一个 exception 对象，该对象包含可识别异常类型的 name 属性和一个描述性的 message 属性。也可以添加其它属性。</p>
<p>4.20、递归函数是直接或间接地调用自身的函数。经典递归函数例子——汉诺塔（更多可见wiki：<a href="http://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94）。" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94）。</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hanoi = <span class="function"><span class="keyword">function</span> <span class="params">(disc, src, aux, dst)</span> </span>{  </div><div class="line">    <span class="keyword">if</span> (disc &gt; <span class="number">0</span>) {  </div><div class="line">        hanoi(disc - <span class="number">1</span>, src, dst, aux);  </div><div class="line">        <span class="built_in">document</span>.writeln(<span class="string">'Move disc '</span> + disc + <span class="string">' from '</span> + src + <span class="string">' to '</span> + dst);  </div><div class="line">        hanoi(disc ? <span class="number">1</span>, aux, src, dst);  </div><div class="line">    }  </div><div class="line">};  </div><div class="line"></div><div class="line">hanoi(<span class="number">3</span>, <span class="string">'Src'</span>, <span class="string">'Aux'</span>, <span class="string">'Dst'</span>);</div></pre></td></tr></table></figure>

<p>圆盘数量为3时返回这样的解法<br>Move disc 1 from Src to Dst<br>Move disc 2 from Src to Aux<br>Move disc 1 from Dst to Aux<br>Move disc 3 from Src to Dst<br>Move disc 1 from Aux to Src<br>Move disc 2 from Aux to Dst<br>Move disc 1 from Src to Dst<br><a href="http://jsfiddle.net/xingxiudong/rpqTw/" target="_blank" rel="external">演示Demo</a></p>
<p>4.21、尾递归是一种在函数的最后执行递归调用语句的特殊形式的递归。</p>
<p>4.22、尾递归可被替换为一个循环，但JavaScript没有对尾递归作出优化。</p>
<p>4.23、作用域控制着变量与参数的可见性及生命周期。作用：1、减少变量名称冲突；2、提供自动内存管理。</p>
<p>4.24、JavaScript不支持代码块的块级作用域。</p>
<p>4.25、JavaScript有函数作用域。定义在函数中的参数和变量在函数外部是不可见的，在函数中的任何位置定义的变量在该函数中的任何地方都是可见的。</p>
<p>4.26、JavaScript因缺少块级作用域，因此建议在函数体的顶部声明函数中可能用到的所有变量。</p>
<p>4.27、作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了 this 和 arguments）。</p>
<p>4.28、闭包例子一：一个有趣的情形是内部函数拥有比它外部函数更长的生命周期</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">    <span class="keyword">var</span> value = <span class="number">0</span>; <span class="comment">// 私有变量，对 increment 和 getValue 可见  </span></div><div class="line">    <span class="keyword">return</span> {  </div><div class="line">        increment : <span class="function"><span class="keyword">function</span> <span class="params">(inc)</span> </span>{  </div><div class="line">            value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;  </div><div class="line">        },  </div><div class="line">        getValue : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">            <span class="keyword">return</span> value;  </div><div class="line">        }  </div><div class="line">    };  </div><div class="line">}();  </div><div class="line">  </div><div class="line"><span class="built_in">document</span>.writeln(myObject.value);       <span class="comment">// undefined  </span></div><div class="line"><span class="built_in">document</span>.writeln(myObject.getValue());  <span class="comment">// 0  </span></div><div class="line">myObject.increment(<span class="number">2</span>);  </div><div class="line"><span class="built_in">document</span>.writeln(myObject.getValue());  <span class="comment">// 2  </span></div><div class="line">myObject.increment(<span class="number">4</span>);  </div><div class="line"><span class="built_in">document</span>.writeln(myObject.getValue());  <span class="comment">// 6</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/xingxiudong/SYpVt/" target="_blank" rel="external">演示Demo</a></p>
<blockquote>
<p>仔细一看，并没有把一个函数赋值给myObject。而是把嗲用该函数后返回的结果赋值给它。该函数返回了包括两个方法的对象，并且这些方法继续享有访问value变量的特权。</p>
</blockquote>
<p>4.29、闭包例子二：创建一个名为 quo 的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 它构造出带有 get_status 方法和 status 私有属性的一个对象  </span></div><div class="line"><span class="keyword">var</span> quo = <span class="function"><span class="keyword">function</span><span class="params">(status)</span></span>{   </div><div class="line">　　<span class="keyword">return</span> {   </div><div class="line">　　　　get_status:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{   </div><div class="line">　　　　　　<span class="keyword">return</span> status;   </div><div class="line">　　　　}  </div><div class="line">　　};  </div><div class="line">};  </div><div class="line"><span class="keyword">var</span> myQuo = quo(<span class="string">"amazed"</span>);   </div><div class="line"><span class="built_in">document</span>.writeln(myQuo.get_status());    <span class="comment">//amazed</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/xingxiudong/z6hHp/" target="_blank" rel="external">演示Demo</a>  </p>
<blockquote>
<p>这个 quo 函数被设计成无须在前面加上 new 来使用，所以名字首字母也没有大写。当我们调用 quo 时，它返回包含 get_status 方法的一个新对象。该对象的一个引用保存在 myQuo 中。即使 quo 已经返回了，但 get_status 方法仍然享有访问 quo 对象的 status 属性的特权。get_status 方法并不是访问该参数的一个拷贝；它访问的就是该参数本身。这是可能的，因为该函数可以访问它被创建时所处的上下文环境。这被称为闭包。</p>
</blockquote>
<p>4.30、闭包例子三：一个更有用的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Define a function that sets a DOM node's color  </span></div><div class="line"><span class="comment">// to yellow and then fades it to white.  </span></div><div class="line"><span class="keyword">var</span> fade = <span class="function"><span class="keyword">function</span> <span class="params">(node)</span> </span>{  </div><div class="line">    <span class="keyword">var</span> level = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">var</span> step = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">        <span class="keyword">var</span> hex = level.toString(<span class="number">16</span>);  </div><div class="line">        node.style.backgroundColor = <span class="string">'#FFFF'</span> + hex + hex;  </div><div class="line">        <span class="keyword">if</span> (level &lt; <span class="number">15</span>) {  </div><div class="line">            level += <span class="number">1</span>;  </div><div class="line">            setTimeout(step, <span class="number">100</span>);  </div><div class="line">        }  </div><div class="line">    };  </div><div class="line">    setTimeout(step, <span class="number">100</span>);  </div><div class="line">};  </div><div class="line"></div><div class="line">fade(<span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/xingxiudong/8bzq9/" target="_blank" rel="external">演示Demo</a>  </p>
<blockquote>
<p>setTimout 存在会让fade函数中的level变量再次被赋值，fade函数在之前已经返回了，但只要fade内部函数需要，它的变量就会持续保留。</p>
</blockquote>
<p>4.31、内部函数访问外部函数的变量是不需要复制的。</p>
<p>4.32、“模块”是一个提供接口却隐藏状态与实现的函数或对象。可以使用函数和闭包来构造模块。</p>
<p>4.33、模块模式利用了函数作用域和闭包来创建绑定对象与私有成员的关联。</p>
<p>4.34、模块模式的一般形式是：最后返回这个特权函数，或者把它们保存到一个可以访问到的地方。</p>
<p>4.35、使用模块模式可以摒弃全局变量的使用。它促进了信息隐藏和其它优秀的设计实践。对于应用程序的封装，或者构造其它单例对象，模块模式非常有效。</p>
<p>4.36、使用模块模式的具有单例的特性产生一个安全的对象 serial_maker。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serial_maker = <span class="function"><span class="keyword">function</span> <span class="params">(  )</span> </span>{  </div><div class="line">  </div><div class="line"><span class="comment">// 返回一个用来产生唯一字符串的对象  </span></div><div class="line"><span class="comment">// 唯一字符串由两部分组成：前缀 + 序列号  </span></div><div class="line"><span class="comment">// 该对象包含一个设置前缀的方法，一个设置序列号的方法和一个产生唯一字符串的 gensym 方法  </span></div><div class="line">  </div><div class="line">    <span class="keyword">var</span> prefix = <span class="string">''</span>;  </div><div class="line">    <span class="keyword">var</span> seq = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">return</span> {  </div><div class="line">        set_prefix: <span class="function"><span class="keyword">function</span> <span class="params">(p)</span> </span>{  </div><div class="line">            prefix = <span class="built_in">String</span>(p);  </div><div class="line">        },  </div><div class="line">        set_seq: <span class="function"><span class="keyword">function</span> <span class="params">(s)</span> </span>{  </div><div class="line">            seq = s;  </div><div class="line">        },  </div><div class="line">        gensym: <span class="function"><span class="keyword">function</span> <span class="params">( )</span> </span>{  </div><div class="line">            <span class="keyword">var</span> result = prefix + seq;  </div><div class="line">            seq += <span class="number">1</span>;  </div><div class="line">            <span class="keyword">return</span> result;  </div><div class="line">        }  </div><div class="line">    };  </div><div class="line">};  </div><div class="line"><span class="keyword">var</span> seqer = serial_maker( );  </div><div class="line">seqer.set_prefix(<span class="string">'Q'</span>);  </div><div class="line">seqer.set_seq(<span class="number">1000</span>);  </div><div class="line"><span class="keyword">var</span> unique = seqer.gensym(); <span class="comment">// unique is "Q1000"  </span></div><div class="line"><span class="built_in">document</span>.writeln(unique);  </div><div class="line"><span class="built_in">document</span>.writeln(seqer.gensym());  </div><div class="line"><span class="built_in">document</span>.writeln(seqer.gensym());  </div><div class="line"><span class="built_in">document</span>.writeln(seqer.gensym());</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/xingxiudong/DLdvK/" target="_blank" rel="external">演示Demo</a></p>
<p>4.37、让一些没有返回值的方法返回 this 而不是 undefined，就启用了级联。</p>
<h2 id="总结">总结</h2>
<ol>
<li>这一章最抽象且难以理解的就是“闭包”。我的理解是，“闭包”是一个函数（假设该函数名为Fa），函数Fa内部有一个子函数（假设该函数名为Fb），子函数Fb能读取其外部父函数Fa的私有变量，它使得内部函数Fb与外部函数Fa之间有一种通信机制，但这一切都在Fa内部有效，离开Fa通信中断，它因与外部不能联系而封闭，所以可以称为“closure”，翻译成中文就成了“闭包”，包可以被理解成其因“闭”而独立。</li>
<li>这篇文章比较通俗易懂地解释了什么是闭包——<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">《学习Javascript闭包（Closure）》</a>。</li>
</ol>
<blockquote>
<p>Refer:<br>英文参考文档：<a href="http://my.safaribooksonline.com/book/programming/javascript/9780596517748" target="_blank" rel="external">《JavaScript: The Good Parts》</a><br>提供学习帮助的网站：  </p>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html" target="_blank" rel="external">《Javascript的10个设计缺陷》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">《学习Javascript闭包（Closure）》</a></li>
<li><a href="http://www.sharejs.com/code/game/Hanoi-Solver.html" target="_blank" rel="external">汉诺塔演示</a></li>
</ol>
</blockquote>
<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>4.1、在JavaScript中，函数就是对象。</p>
<p>4.2、函数的对象连接到Function.prototype（该原型对象本身被连接到Object.prototype）。</p>
<p>4.3、函数在创建的时候附有两个附加的隐藏属性：函数上下文和实现函数行为的代码。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第三章 对象]]></title>
    <link href="http://xingxiudong.com/2012/06/14/javascript-the-good-parts-reading-notes-ch3/"/>
    <id>http://xingxiudong.com/2012/06/14/javascript-the-good-parts-reading-notes-ch3/</id>
    <published>2012-06-13T17:28:30.000Z</published>
    <updated>2015-01-05T07:24:54.000Z</updated>
    <content type="html"><![CDATA[<p>3.1、JavaScript简单的类型包括数字、字符串、布尔值（true和false）、null值和undefined值。其他所有的值都是对象。</p>
<p>3.2、JavaScript中的对象是可变键控集合。在JavaScript中，数组是对象，函数是对象，正则表达式是对象，对象也是对象。</p>
<p>3.3、对象是属性的容器，每个属性都拥有名字和值。属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除undefined值之外的任何值。<br><a id="more"></a></p>
<p>3.4、检索对象中包含的值，可以用[]，也可以用.（前提是属性字符串是一个常数，且是一个合法的JavaScript标识符并非保留字），优先考虑用.表示法，因为它可读性更好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = {  </div><div class="line">    <span class="string">"first-name"</span> : <span class="string">"Zhang"</span>,  </div><div class="line">    <span class="string">"middle-name"</span> : <span class="string">"Yi"</span>,  </div><div class="line">    <span class="string">"last-name"</span> : <span class="string">"Mou"</span>,  </div><div class="line">    <span class="string">'age'</span> : <span class="number">60</span>,  </div><div class="line">}  </div><div class="line">Person[<span class="string">"first-name"</span>]; <span class="comment">// Zhang  </span></div><div class="line">Person.age; <span class="comment">// 60</span></div></pre></td></tr></table></figure>

<p>3.5、|| 运算符可以用来填充默认值：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> middleName = Person[<span class="string">"middle-name"</span>] || <span class="string">"none"</span>;  </div><div class="line"><span class="keyword">var</span> tel = Person.tel || <span class="string">"unknown"</span>;</div></pre></td></tr></table></figure>

<p>3.7、&amp;&amp; 运算符可以用来避免因尝试检索一个undefined值而导致的TypeError异常。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person.tel <span class="comment">// undefined  </span></div><div class="line">Person.tel.number<span class="comment">// throw "TypeError"  </span></div><div class="line">Person.tel && Person.tel.number <span class="comment">// undefined</span></div></pre></td></tr></table></figure>

<p>3.8、对象通过引用来传递，他们永远不会被拷贝。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = {}, b = {}, c = {}; <span class="comment">// a、b、c每个都引用一个不同的空对象  </span></div><div class="line">a = b = c = {}; <span class="comment">// a、b、c都引用同一个空对象</span></div></pre></td></tr></table></figure>

<p>3.9、每个对象都能连接到一个原型对象prototype，并且它可以从中继承属性。所有通过对象字面量创建的对象都链接到Object.prototype这个JavaScript中标准的对象。</p>
<p>3.10、原型连接在更新的时候不起作用，对某个对象作出改变时，不会触及到该对象的原型。</p>
<p>3.11、原型连接只有在检索值的时候才能被用到。如果我们尝试去获取对象的某个值，且该对象没有此属性名，那么JavaScript会尝试着从其原型对象中获取属性值。如果那个原型对象也没有该属性值，那么再从它的原型中寻找，依此类推，知道该过程最后达到终点Object.prototype。如果想要的属性完全不存在于原型链中，那么结果就是undefined值。这个过程成为“委托”。</p>
<p>3.12、hasOwnProperty()方法用来检索对象自身独有的属性，存在返回true，不会检查原型链。</p>
<p>3.13、for in语句可遍历对象中的所有属性名，包括原型链。可以使用hasOwnProperty方法或typeof方法来作过滤器。</p>
<p>3.14、delete运算符用来删除对象的属性，但不会触及到原型链中的任何对象。<br>3.15、最小化使用全局变量的一个方法是在你的应用中只创建唯一一个全局变量：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MYAPP = {};</div></pre></td></tr></table></figure>


<p>该变量此时变成了应用的容器：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MYAPP.Person = { ... };  </div><div class="line">MyApp.Weather = { ... };</div></pre></td></tr></table></figure>



<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>3.1、JavaScript简单的类型包括数字、字符串、布尔值（true和false）、null值和undefined值。其他所有的值都是对象。</p>
<p>3.2、JavaScript中的对象是可变键控集合。在JavaScript中，数组是对象，函数是对象，正则表达式是对象，对象也是对象。</p>
<p>3.3、对象是属性的容器，每个属性都拥有名字和值。属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除undefined值之外的任何值。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《JavaScript 语言精粹》 读书笔记 —— 第二章 语法]]></title>
    <link href="http://xingxiudong.com/2012/06/14/javascript-the-good-parts-reading-notes-ch2/"/>
    <id>http://xingxiudong.com/2012/06/14/javascript-the-good-parts-reading-notes-ch2/</id>
    <published>2012-06-13T17:28:01.000Z</published>
    <updated>2015-01-05T07:24:41.000Z</updated>
    <content type="html"><![CDATA[<p>2.1、JSLint是一个JavaScript解析器，它能分析JavaScript问题并报告它包含的缺点。它能让你确信你的程序只包含精华的部分。</p>
<p>2.2、没有用的注释比没有注释更糟糕。<br><a id="more"></a></p>
<p>2.3、由于块注释（/<em> </em>/）的有些字符可能出现在正则表达式上，不建议使用/<em> </em>/注释，而采用//替代它，例如：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line">    var rm_a = /a*/.match(s);</div><div class="line">*<span class="regexp">/</span></div></pre></td></tr></table></figure>

<p>2.4、JavaScript中，数字只有一个类型——64位的浮点数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="number">1</span> === <span class="number">1.0</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>2.5、NaN是一个数值，它表示一个不能产生正常结果的运算结果。NaN不等于任何值，包括它自己，alert(NaN === NaN); // false。用isNaN( number )检测number是否为NaN。</p>
<p>2.6、Infinity表示所有大于1.79769313486231570e+308的值。</p>
<p>2.7、JavaScript没有字符类型。</p>
<p>2.8、字符串有一个length属性。</p>
<p>2.9、字符串是不可变的。</p>
<p>2.10、当var语句在被用在函数内部时，它定义了这个函数的私有变量。</p>
<p>2.11、这些值被当作假（false）：false、null、undefined、空字符串’ ‘、数字0、数字NaN，其他所有的值被当作真，包括true、字符串”false”，以及所有的对象。</p>
<p>2.12、for in语句用来枚举一个对象所有的属性名。</p>
<p>2.13、JavaScript不允许在return关键字和表达式之间换行。</p>
<p>2.14、typeof运算符产生的值有6种：’number’、’string’、’boolean’、’undefined’、’function’、’object’。</p>
<p>2.15、+ 运算符可以进行加法运算或字符串连接。如果要进行加法运算，必须确保两个运算数必须都是数字。</p>
<p><img src="/images/javascript-the-good-parts-cover-s.jpg" alt="书籍封面"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2.1、JSLint是一个JavaScript解析器，它能分析JavaScript问题并报告它包含的缺点。它能让你确信你的程序只包含精华的部分。</p>
<p>2.2、没有用的注释比没有注释更糟糕。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://xingxiudong.com/tags/javascript/"/>
    
      <category term="javascript" scheme="http://xingxiudong.com/categories/javascript/"/>
    
  </entry>
  
</feed>
